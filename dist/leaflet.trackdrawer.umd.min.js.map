{"version":3,"file":"leaflet.trackdrawer.umd.min.js","sources":["../node_modules/regenerator-runtime/runtime.js","../node_modules/@babel/runtime/helpers/asyncToGenerator.js","../src/Colors.js","../src/LayerContainer.js","../src/Edge.js","../src/Track.js","../src/ToolBar.js","../src/TraceModeBar.js","../src/Node.js","../src/LatLngUtils.js","../src/Loader.js","../src/index.js"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","const colorMap = {\n  red: '#D63E2A',\n  orange: '#F59630',\n  green: '#72B026',\n  blue: '#38AADD',\n  purple: '#D252B9',\n  darkred: '#A23336',\n  darkblue: '#0067A3',\n  darkgreen: '#728224',\n  darkpurple: '#5B396B',\n  cadetblue: '#436978',\n  lightred: '#FF8E7F',\n  beige: '#FFCB92',\n  lightgreen: '#BBF970',\n  lightblue: '#8ADAFF',\n  pink: '#FF91EA',\n  white: '#FBFBFB',\n  lightgray: '#A3A3A3',\n  gray: '#575757',\n  black: '#303030',\n};\nconst colors = [\n  'blue',\n  'green',\n  'orange',\n  'purple',\n  'red',\n  'darkblue',\n  'darkpurple',\n  'lightblue',\n  'lightgreen',\n  'beige',\n  'pink',\n  'lightred',\n]; // Colors supported by Leaflet AwesomeMarkers\n\nObject.freeze(colorMap);\nObject.freeze(colors);\n\nmodule.exports = {\n  nameOf(idx) {\n    return colors[idx % colors.length];\n  },\n\n  rgbOf(idx) {\n    return colorMap[this.nameOf(idx)];\n  },\n\n  nameToRgb(name) {\n    return colorMap[name];\n  },\n\n  rgbToName(rgb) {\n    return Object.keys(colorMap).find((key) => colorMap[key] === rgb);\n  },\n};\n","const L = require('leaflet');\n\nmodule.exports = L.Evented.extend({\n  initialize(parent) {\n    this._parent = parent;\n    const f = L.featureGroup()\n      .addTo(parent)\n      .addEventParent(this);\n    this._elements = [f];\n    this.length = 1;\n  },\n\n  get(i) {\n    const idx = i < 0 ? this._elements.length + i : i;\n    return this._elements[idx];\n  },\n\n  /* eslint-disable prefer-rest-params */\n  splice() {\n    const ret = this._elements.splice(...arguments);\n    ret.forEach((x) => x.removeFrom(this._parent).removeEventParent(this));\n\n    if (arguments.length > 2) {\n      const args = Array.prototype.slice.call(arguments, 2);\n      args.forEach((x) => {\n        x.addTo(this._parent).addEventParent(this);\n      });\n    }\n\n    this.length = this._elements.length;\n    return ret;\n  },\n  /* eslint-enable prefer-rest-params */\n\n  forEach(cb) {\n    this._elements.forEach(cb);\n  },\n\n  clean() {\n    this._elements[0].clearLayers();\n    this.splice(1);\n  },\n\n  getLayer(id) {\n    const parentLayer = this._elements.find((x) => x.getLayer(id) !== undefined);\n    return parentLayer !== undefined ? parentLayer.getLayer(id) : undefined;\n  },\n  getLayerId(layer) {\n    const parentLayer = this._elements.find((x) => x.hasLayer(layer));\n    return parentLayer !== undefined ? parentLayer.getLayerId(layer) : undefined;\n  },\n  getLayerIndex(layer) {\n    return this._elements.findIndex((x) => x.hasLayer(layer));\n  },\n});\n","const L = require('leaflet');\n\nconst Edge = L.Polyline.extend({\n  _startMarkerId: undefined,\n  _endMarkerId: undefined,\n  _promoted: false,\n  _demoted: true,\n  _computation: 0,\n\n  options: { metadata: {} },\n\n  initialize(latlngs, options) {\n    L.Polyline.prototype.initialize.call(this, latlngs, options);\n    L.setOptions(this, options);\n    this.options.metadata = JSON.parse(JSON.stringify(this.options.metadata));\n  },\n});\n\nmodule.exports = {\n  Edge,\n  edge(latlngs, options) {\n    return new Edge(latlngs, options);\n  },\n};\n","const L = require('leaflet');\nconst Colors = require('./Colors');\nconst LayerContainer = require('./LayerContainer');\nconst { Edge } = require('./Edge');\n\nfunction encodeLatLngs(latlngs) {\n  const array = [];\n  const size = latlngs.length;\n  for (let i = 0; i < size; i += 1) {\n    array.push(latlngs[i].lat);\n    array.push(latlngs[i].lng);\n  }\n  return array;\n\n  /* polyline with precision of 8 seems broken\n\n    var array = latlngs.map(function(x) {\n      return [x.lat, x.lng];\n    });\n\n    return polyline.encode(array, 8); //\n    */\n}\n\nfunction decodeLatLngs(latlngs) {\n  const array = [];\n  const size = latlngs.length;\n  for (let i = 0; i < size; i += 2) {\n    array.push(L.latLng(latlngs[i], latlngs[i + 1]));\n  }\n  return array;\n\n  /* polyline with precision of 8 seems broken\n\n    var decoded = polyline.decode(latlngs, 8);\n\n    return decoded.map(function(x) {\n      return L.latLng(x[0], x[1]);\n    });\n    */\n}\n\nfunction encodeLatLng(latlng) {\n  return [latlng.lat, latlng.lng];\n}\n\nfunction decodeLatLng(latlng) {\n  return L.latLng(latlng[0], latlng[1]);\n}\n\nconst Track = L.LayerGroup.extend({\n  options: {\n    routingCallback: undefined,\n    router: undefined,\n    debug: false,\n    undoable: true,\n    undoDepth: 30,\n  },\n\n  _getPrevious(node) {\n    const previousEdge = node !== undefined ? this._getEdge(node._routeIdPrevious) : undefined;\n    const previousNode = previousEdge !== undefined ? this._getNode(previousEdge._startMarkerId) : undefined;\n    return { previousEdge, previousNode };\n  },\n\n  _getNext(node) {\n    const nextEdge = node !== undefined ? this._getEdge(node._routeIdNext) : undefined;\n    const nextNode = nextEdge !== undefined ? this._getNode(nextEdge._endMarkerId) : undefined;\n    return { nextEdge, nextNode };\n  },\n\n  _getNodeId(node) {\n    return this._nodesContainers.getLayerId(node);\n  },\n  _getEdgeId(edge) {\n    return this._edgesContainers.getLayerId(edge);\n  },\n  _getNode(id) {\n    return this._nodesContainers.getLayer(id);\n  },\n  _getEdge(id) {\n    return this._edgesContainers.getLayer(id);\n  },\n  _getNodeContainerIndex(node) {\n    return this._nodesContainers.getLayerIndex(node);\n  },\n  _getNodeContainer(node) {\n    return this._nodesContainers.get(this._getNodeContainerIndex(node));\n  },\n  _getEdgeContainerIndex(edge) {\n    return this._edgesContainers.getLayerIndex(edge);\n  },\n  _getEdgeContainer(edge) {\n    return this._edgesContainers.get(this._getEdgeContainerIndex(edge));\n  },\n\n  initialize(options) {\n    this.setOptions(options);\n    L.LayerGroup.prototype.initialize.call(this);\n\n    this._nodesContainers = new LayerContainer(this);\n    this._edgesContainers = new LayerContainer(this);\n    this._firstNodeId = undefined;\n    this._lastNodeId = undefined;\n    this._currentColorIndex = 0;\n    this._fireEvents = true;\n    this._computing = 0;\n\n    this._states = null;\n    this._currentStateIndex = null;\n\n    if (this.options.undoable) {\n      this._states = [];\n      this._states.push(this.getState());\n      this._currentStateIndex = 0;\n    }\n  },\n\n  setOptions(options) {\n    L.setOptions(this, options);\n\n    if (this.options.router !== undefined) {\n      this.options.routingCallback = (previousMarker, marker, done) => {\n        this.options.router.route(\n          [L.Routing.waypoint(previousMarker.getLatLng()), L.Routing.waypoint(marker.getLatLng())],\n          (err, result) => {\n            done(err, result ? result[0].coordinates : null, {});\n          },\n        );\n      };\n    }\n  },\n\n  hasNodes(count = 1) {\n    let counter = 0;\n    this._nodesContainers.forEach((container) => {\n      const group = container.getLayers();\n      counter += group.length;\n    });\n    return counter >= count;\n  },\n\n  getNodes() {\n    const nodes = [];\n\n    this._nodesContainers.forEach((container) => {\n      const group = container.getLayers();\n      if (group.length > 0) nodes.push({ container, markers: group });\n    });\n\n    return nodes;\n  },\n  getNodesContainer() {\n    return this._nodesContainers;\n  },\n\n  getSteps() {\n    const steps = [];\n\n    this._edgesContainers.forEach((container) => {\n      const group = container.getLayers();\n      if (group.length > 0) steps.push({ container, edges: group });\n    });\n\n    return steps;\n  },\n  getStepsContainer() {\n    return this._edgesContainers;\n  },\n\n  getBounds() {\n    const bounds = L.latLngBounds([]);\n\n    this._nodesContainers.forEach((container) => {\n      bounds.extend(container.getBounds());\n    });\n\n    this._edgesContainers.forEach((container) => {\n      bounds.extend(container.getBounds());\n    });\n    return bounds;\n  },\n\n  getLatLngs() {\n    const hasTrackStats = L.TrackStats !== undefined;\n    const latlngs = [];\n\n    let currentNode = this._getNode(this._firstNodeId);\n    this._nodesContainers.forEach(() => {\n      const l = [];\n      do {\n        const { nextEdge, nextNode } = this._getNext(currentNode);\n        if (currentNode === undefined || nextEdge === undefined) {\n          break;\n        }\n\n        nextEdge.getLatLngs().forEach((e) => {\n          l.push(hasTrackStats ? L.TrackStats.cache.getAll(e) : e);\n        });\n\n        currentNode = nextNode;\n      } while (currentNode.options.type !== 'stopover');\n\n      latlngs.push(JSON.parse(JSON.stringify(l)));\n    });\n\n    return latlngs;\n  },\n\n  _stopoversToGeoJSON() {\n    const stopovers = [];\n    const features = [];\n\n    let currentNode = this._getNode(this._firstNodeId);\n\n    if (currentNode !== undefined) {\n      stopovers.push(currentNode);\n    }\n    this._nodesContainers.forEach(() => {\n      do {\n        const { nextEdge, nextNode } = this._getNext(currentNode);\n        if (currentNode === undefined || nextEdge === undefined) {\n          break;\n        }\n\n        currentNode = nextNode;\n      } while (currentNode.options.type !== 'stopover');\n\n      if (currentNode !== undefined) {\n        stopovers.push(currentNode);\n      }\n    });\n\n    const hasTrackStats = L.TrackStats !== undefined;\n    stopovers.forEach((node, idx) => {\n      const e = hasTrackStats ? L.TrackStats.cache.getAll(node.getLatLng()) : node.getLatLng();\n      const properties = JSON.parse(JSON.stringify(node.options.metadata));\n      properties.index = idx;\n\n      features.push({\n        type: 'Feature',\n        properties,\n        geometry: {\n          type: 'Point',\n          coordinates: 'z' in e && e.z !== null ? [e.lng, e.lat, e.z] : [e.lng, e.lat],\n        },\n      });\n    });\n\n    return features;\n  },\n\n  _edgesToFlatGeoJSON() {\n    const hasTrackStats = L.TrackStats !== undefined;\n    const feature = {\n      type: 'Feature',\n      properties: { index: 0 },\n      geometry: {\n        type: 'LineString',\n        coordinates: [],\n      },\n    };\n\n    let currentNode = this._getNode(this._firstNodeId);\n    this._nodesContainers.forEach(() => {\n      do {\n        const { nextEdge, nextNode } = this._getNext(currentNode);\n        if (currentNode === undefined || nextEdge === undefined) {\n          break;\n        }\n\n        nextEdge.getLatLngs().forEach((e) => {\n          const e2 = hasTrackStats ? L.TrackStats.cache.getAll(e) : e;\n          feature.geometry.coordinates.push('z' in e2 && e2.z !== null ? [e2.lng, e2.lat, e2.z] : [e2.lng, e2.lat]);\n        });\n\n        currentNode = nextNode;\n      } while (currentNode.options.type !== 'stopover');\n    });\n\n    return feature;\n  },\n\n  _edgesToGeoJSON() {\n    const hasTrackStats = L.TrackStats !== undefined;\n    const features = [];\n\n    let currentNode = this._getNode(this._firstNodeId);\n    this._nodesContainers.forEach((_c, idx) => {\n      do {\n        const { nextEdge, nextNode } = this._getNext(currentNode);\n        if (currentNode === undefined || nextEdge === undefined) {\n          break;\n        }\n\n        const properties = JSON.parse(JSON.stringify(nextEdge.options.metadata));\n        properties.index = idx;\n\n        const feature = {\n          type: 'Feature',\n          properties,\n          geometry: {\n            type: 'LineString',\n            coordinates: [],\n          },\n        };\n\n        nextEdge.getLatLngs().forEach((e) => {\n          const e2 = hasTrackStats ? L.TrackStats.cache.getAll(e) : e;\n          feature.geometry.coordinates.push('z' in e2 && e2.z !== null ? [e2.lng, e2.lat, e2.z] : [e2.lng, e2.lat]);\n        });\n\n        features.push(feature);\n\n        currentNode = nextNode;\n      } while (currentNode.options.type !== 'stopover');\n    });\n\n    return features;\n  },\n\n  toGeoJSON(exportStopovers = true, exportAsFlat = false) {\n    const geojson = {\n      type: 'FeatureCollection',\n      features: [],\n    };\n\n    if (exportStopovers) {\n      this._stopoversToGeoJSON().forEach((f) => geojson.features.push(f));\n    }\n\n    if (exportAsFlat) {\n      geojson.features.push(this._edgesToFlatGeoJSON());\n    } else {\n      this._edgesToGeoJSON().forEach((f) => geojson.features.push(f));\n    }\n\n    return geojson;\n  },\n\n  getState() {\n    const state = [\n      {\n        version: 2,\n        start: undefined,\n        metadata: undefined,\n      },\n    ];\n    let currentNode = this._getNode(this._firstNodeId);\n\n    if (currentNode !== undefined) {\n      state[0].start = encodeLatLng(currentNode.getLatLng());\n      state[0].metadata = JSON.parse(JSON.stringify(currentNode.options.metadata));\n    }\n\n    this._nodesContainers.forEach(() => {\n      const group = [];\n\n      do {\n        const { nextEdge, nextNode } = this._getNext(currentNode);\n        if (currentNode === undefined || nextEdge === undefined) {\n          break;\n        }\n\n        group.push({\n          end: encodeLatLng(nextNode.getLatLng()),\n          edge: encodeLatLngs(nextEdge.getLatLngs()),\n          metadata: {\n            node: JSON.parse(JSON.stringify(nextNode.options.metadata)),\n            edge: JSON.parse(JSON.stringify(nextEdge.options.metadata)),\n          },\n        });\n\n        currentNode = nextNode;\n      } while (currentNode.options.type !== 'stopover');\n\n      if (group.length > 0) state.push(group);\n    });\n\n    return state;\n  },\n\n  _fireStart(payload = {}) {\n    if (this._fireEvents && this._computing === 0) this.fire('TrackDrawer:start', payload);\n    this._computing += 1;\n  },\n\n  _fireDone(payload = {}) {\n    this._computing -= 1;\n    // TODO: find a way to store states while computing\n    if (this._fireEvents && this._computing === 0) this._pushState();\n    if (this._fireEvents && this._computing === 0) this.fire('TrackDrawer:done', payload);\n  },\n\n  _fireFailed(error) {\n    this._computing -= 1;\n    if (this._fireEvents && this._computing === 0) this.fire('TrackDrawer:failed', { message: error.message });\n  },\n\n  async refreshEdges(routingCallback) {\n    const callback = routingCallback || this.options.routingCallback;\n\n    this._fireStart();\n    const oldValue = this._fireEvents;\n    this._fireEvents = false;\n\n    const promises = [];\n    this._nodesContainers.forEach((container) => {\n      const markers = container.getLayers();\n      markers.forEach((marker) => {\n        promises.push(this.onMoveNode(marker, callback));\n      });\n    });\n\n    await Promise.all(promises);\n\n    this._fireEvents = oldValue;\n    this._fireDone();\n    return this;\n  },\n\n  clean() {\n    this._fireStart();\n    this._edgesContainers.clean();\n    this._nodesContainers.clean();\n\n    this._firstNodeId = undefined;\n    this._lastNodeId = undefined;\n    this._currentColorIndex = 0;\n\n    this._fireDone();\n    return this;\n  },\n\n  _createNode(latlng, metadata = {}) {\n    return L.TrackDrawer.node(latlng, { metadata });\n  },\n\n  async restoreState(state, nodeCallback) {\n    const callback = nodeCallback || this._createNode;\n    this._fireStart();\n\n    const oldValue = this._fireEvents;\n    this._fireEvents = false;\n    this.clean();\n\n    const stopovers = [];\n    const routes = [];\n    const promises = [];\n\n    let version;\n\n    state.forEach((group, i) => {\n      if (i === 0) {\n        // eslint-disable-next-line prefer-destructuring\n        version = group.version;\n        if (group.start) {\n          const marker = callback.call(null, decodeLatLng(group.start), version >= 2 ? group.metadata : {});\n          promises.push(\n            this.addNode(\n              marker,\n              () => {\n                throw new Error('Should not be called');\n              },\n              true,\n            ),\n          );\n        }\n        return;\n      }\n\n      group.forEach((segment, j) => {\n        const marker = callback.call(null, decodeLatLng(segment.end), version >= 2 ? segment.metadata.node : {});\n        if (j === group.length - 1 && i < state.length - 1) {\n          stopovers.push(marker);\n        }\n\n        promises.push(\n          this.addNode(\n            marker,\n            (from, to, done) => {\n              const edge = decodeLatLngs(segment.edge);\n              routes.push({ from, to, edge });\n              done(null, edge, version >= 2 ? segment.metadata.edge : {});\n            },\n            true,\n          ),\n        );\n      });\n    });\n\n    await Promise.all(promises);\n\n    stopovers.forEach((m) => this.promoteNodeToStopover(m));\n\n    this._fireEvents = oldValue;\n    this._fireDone({ routes });\n    return this;\n  },\n\n  _pushState() {\n    if (this.options.undoable && !this._undoing) {\n      if (this._currentStateIndex + 1 !== this._states.length) {\n        this._states.splice(this._currentStateIndex + 1);\n      }\n      this._currentStateIndex += 1;\n      this._states.push(this.getState());\n\n      if (this._states.length - 1 > this.options.undoDepth) {\n        this._states.splice(0, 1);\n        this._currentStateIndex -= 1;\n      }\n    }\n  },\n\n  async undo(nodeCallback) {\n    if (this.isUndoable() && this._computing === 0) {\n      this._currentStateIndex -= 1;\n      this._undoing = true;\n      await this.restoreState(this._states[this._currentStateIndex], nodeCallback);\n      this._undoing = false;\n      return true;\n    }\n    return false;\n  },\n\n  isUndoable() {\n    return this.options.undoable && this._currentStateIndex > 0;\n  },\n\n  isRedoable() {\n    return this.options.undoable && this._currentStateIndex < this._states.length - 1;\n  },\n\n  async redo(nodeCallback) {\n    if (this.isRedoable() && this._computing === 0) {\n      this._currentStateIndex += 1;\n      this._undoing = true;\n      await this.restoreState(this._states[this._currentStateIndex], nodeCallback);\n      this._undoing = false;\n      return true;\n    }\n    return false;\n  },\n\n  addLayer(layer) {\n    if (layer instanceof L.Marker) {\n      this.addNode(layer);\n    } else {\n      L.LayerGroup.prototype.addLayer.call(this, layer);\n    }\n  },\n\n  _createEdge(previousNode, node, metadata = {}) {\n    const edgesContainer = this._edgesContainers.get(this._getNodeContainerIndex(previousNode));\n    const edge = new Edge([previousNode.getLatLng(), node.getLatLng()], {\n      color: Colors.nameToRgb(previousNode.options.colorName),\n      dashArray: '4',\n      metadata,\n    }).addTo(edgesContainer);\n    const id = edgesContainer.getLayerId(edge);\n\n    previousNode._routeIdNext = id;\n    node._routeIdPrevious = id;\n    edge._startMarkerId = this._getNodeId(previousNode);\n    edge._endMarkerId = this._getNodeId(node);\n    edge._computation = 0;\n\n    if (this.options.debug) {\n      edge.on('tooltipopen', () => {\n        const startNodeId = edge._startMarkerId;\n        const endNodeId = edge._endMarkerId;\n\n        edge.setTooltipContent(\n          `id: ${this._getEdgeId(edge)} (on #${this._getEdgeContainerIndex(edge)})<br>`\n          + `previous node: ${startNodeId}`\n          + ` (on #${this._getNodeContainerIndex(this._getNode(startNodeId))})<br>`\n          + `next node: ${endNodeId}`\n          + ` (on #${this._getNodeContainerIndex(this._getNode(endNodeId))})`,\n        );\n      });\n      edge.bindTooltip('<>');\n    }\n\n    return edge;\n  },\n\n  _prepareNode(node, nodesContainer) {\n    if (this.options.debug) {\n      node.on('tooltipopen', () => {\n        const { previousEdge, previousNode } = this._getPrevious(node);\n        const { nextEdge, nextNode } = this._getNext(node);\n\n        node.setTooltipContent(\n          `id: ${this._getNodeId(node)} (on #${this._getNodeContainerIndex(node)})<br>`\n          + `previous edge: ${this._getEdgeId(previousEdge)}`\n          + ` (on #${this._getEdgeContainerIndex(previousEdge)}) to ${this._getNodeId(previousNode)}<br>`\n          + `next edge: ${this._getEdgeId(nextEdge)}`\n          + ` (on #${this._getEdgeContainerIndex(nextEdge)}) to ${this._getNodeId(nextNode)}`,\n        );\n      });\n      node.bindTooltip('<>');\n    }\n\n    if (nodesContainer.getLayers().length > 0) {\n      const previousNode = nodesContainer.getLayers()[0];\n      node.setStyle({ colorName: previousNode.options.colorName });\n    } else {\n      node.setStyle({ colorName: Colors.nameOf(this._currentColorIndex) });\n    }\n\n    if (node.options.draggable) {\n      node.on('dragstart', (e) => this._onDragStartNode(e.target));\n      node.on('drag', (e) => this._onDragNode(e.target));\n      node.on('moveend', (e) => this.onMoveNode(e.target));\n    }\n\n    node.addTo(nodesContainer);\n\n    return this;\n  },\n\n  addNode(node, routingCallback, skipChecks = false) {\n    const callback = routingCallback || this.options.routingCallback;\n\n    if (this._lastNodeId !== undefined && !skipChecks) {\n      const previousNode = this._getNode(this._lastNodeId);\n      if (previousNode.getLatLng().equals(node.getLatLng())) {\n        return new Promise((resolve) => {\n          resolve();\n        });\n      }\n    }\n\n    this._fireStart();\n\n    const nodesContainer = this._nodesContainers.get(-1);\n    this._prepareNode(node, nodesContainer);\n\n    if (this._lastNodeId !== undefined) {\n      const previousNode = this._getNode(this._lastNodeId);\n      this._createEdge(previousNode, node);\n    }\n\n    const lastNodeId = this._lastNodeId;\n    this._lastNodeId = this._getNodeId(node);\n    if (this._firstNodeId === undefined) {\n      this._firstNodeId = this._lastNodeId;\n    }\n\n    const oldValue = this._fireEvents;\n    this._fireEvents = false;\n    if (node.options.type === 'stopover') {\n      this.promoteNodeToStopover(node);\n    }\n    this._fireEvents = oldValue;\n\n    if (lastNodeId === undefined) {\n      return new Promise((resolve) => {\n        resolve();\n      }).then(() => {\n        this._fireDone({});\n      });\n    }\n\n    const { previousEdge, previousNode } = this._getPrevious(node);\n    previousEdge._computation += 1;\n    const currentComputation = previousEdge._computation;\n\n    return new Promise((resolve, reject) => {\n      callback.call(null, previousNode, node, (err, route, metadata = {}) => {\n        if (err !== null) {\n          reject(err);\n          return;\n        }\n\n        if (previousEdge._computation === currentComputation) {\n          // Route can give different precision than initial markers\n          // Use precision given by the route to be consistent\n          previousNode.setLatLng(L.latLng(route[0]));\n          node.setLatLng(L.latLng(route[route.length - 1]));\n          previousEdge.setLatLngs(route);\n          previousEdge.options.metadata = JSON.parse(JSON.stringify(metadata));\n          previousEdge.setStyle({ dashArray: null });\n        }\n\n        resolve({ routes: [{ from: previousNode, to: node, previousEdge }] });\n      });\n    })\n      .then((routes) => {\n        this._fireDone({ routes });\n      })\n      .catch((e) => {\n        this._fireFailed(e);\n      });\n  },\n\n  insertNode(node, route, routingCallback) {\n    const callback = routingCallback || this.options.routingCallback;\n\n    const startMarker = this._getNode(route._startMarkerId);\n    const endMarker = this._getNode(route._endMarkerId);\n\n    route.removeFrom(this._getEdgeContainer(route));\n    this._prepareNode(node, this._getNodeContainer(startMarker));\n\n    const edge1 = this._createEdge(startMarker, node);\n    const edge2 = this._createEdge(node, endMarker);\n\n    this._fireStart();\n\n    edge1._computation += 1;\n    edge2._computation += 1;\n    const currentComputation1 = edge1._computation;\n    const currentComputation2 = edge2._computation;\n\n    const promise1 = new Promise((resolve, reject) => {\n      callback.call(null, startMarker, node, (err, route1, metadata1 = {}) => {\n        if (err !== null) {\n          reject(err);\n          return;\n        }\n\n        if (edge1._computation === currentComputation1) {\n          startMarker.setLatLng(L.latLng(route1[0]));\n          node.setLatLng(L.latLng(route1[route1.length - 1]));\n          edge1.setLatLngs(route1);\n          edge1.options.metadata = JSON.parse(JSON.stringify(metadata1));\n          edge1.setStyle({ dashArray: null });\n        }\n        resolve({ from: startMarker, to: node, edge: edge1 });\n      });\n    });\n\n    const promise2 = new Promise((resolve, reject) => {\n      callback.call(null, node, endMarker, (err, route2, metadata2 = {}) => {\n        if (err !== null) {\n          reject(err);\n          return;\n        }\n\n        if (edge2._computation === currentComputation2) {\n          node.setLatLng(L.latLng(route2[0]));\n          endMarker.setLatLng(L.latLng(route2[route2.length - 1]));\n          edge2.setLatLngs(route2);\n          edge2.options.metadata = JSON.parse(JSON.stringify(metadata2));\n          edge2.setStyle({ dashArray: null });\n        }\n        resolve({ from: node, to: endMarker, edge: edge2 });\n      });\n    });\n\n    return Promise.all([promise1, promise2])\n      .then((routes) => {\n        this._fireDone({ routes });\n      })\n      .catch((e) => {\n        this._fireFailed(e);\n      });\n  },\n\n  _onDragStartNode(marker) {\n    const { previousEdge } = this._getPrevious(marker);\n    const { nextEdge } = this._getNext(marker);\n    if (previousEdge !== undefined) {\n      previousEdge.setStyle({ dashArray: '4' });\n    }\n    if (nextEdge !== undefined) {\n      nextEdge.setStyle({ dashArray: '4' });\n    }\n    return this;\n  },\n\n  _onDragNode(marker) {\n    const { previousEdge, previousNode } = this._getPrevious(marker);\n    const { nextEdge, nextNode } = this._getNext(marker);\n    if (previousEdge !== undefined) {\n      previousEdge.setLatLngs([previousNode.getLatLng(), marker.getLatLng()]);\n    }\n    if (nextEdge !== undefined) {\n      nextEdge.setLatLngs([nextNode.getLatLng(), marker.getLatLng()]);\n    }\n    return this;\n  },\n\n  onMoveNode(marker, routingCallback) {\n    const callback = routingCallback || this.options.routingCallback;\n\n    const promises = [];\n    const { previousEdge, previousNode } = this._getPrevious(marker);\n    const { nextEdge, nextNode } = this._getNext(marker);\n\n    this._fireStart();\n    this._onDragStartNode(marker);\n    this._onDragNode(marker);\n\n    if (previousEdge !== undefined) {\n      previousEdge._computation += 1;\n      const currentComputation = previousEdge._computation;\n\n      promises.push(\n        new Promise((resolve, reject) => {\n          callback.call(null, previousNode, marker, (err, route, metadata = {}) => {\n            if (err !== null) {\n              reject(err);\n              return;\n            }\n\n            if (previousEdge._computation === currentComputation) {\n              marker.setLatLng(L.latLng(route[route.length - 1]));\n              previousEdge.setLatLngs(route);\n              previousEdge.options.metadata = JSON.parse(JSON.stringify(metadata));\n              previousEdge.setStyle({ dashArray: null });\n            }\n\n            resolve({ from: previousNode, to: marker, edge: previousEdge });\n          });\n        }),\n      );\n    }\n\n    if (nextEdge !== undefined) {\n      nextEdge._computation += 1;\n      const currentComputation = nextEdge._computation;\n\n      promises.push(\n        new Promise((resolve, reject) => {\n          callback.call(null, marker, nextNode, (err, route, metadata = {}) => {\n            if (err !== null) {\n              reject(err);\n              return;\n            }\n\n            if (nextEdge._computation === currentComputation) {\n              marker.setLatLng(L.latLng(route[0]));\n              nextEdge.setLatLngs(route);\n              nextEdge.options.metadata = JSON.parse(JSON.stringify(metadata));\n              nextEdge.setStyle({ dashArray: null });\n            }\n\n            resolve({ from: marker, to: nextNode, edge: nextEdge });\n          });\n        }),\n      );\n    }\n\n    return Promise.all(promises)\n      .then((routes) => {\n        this._fireDone({ routes });\n      })\n      .catch((e) => {\n        this._fireFailed(e);\n      });\n  },\n\n  removeNode(node, routingCallback) {\n    const callback = routingCallback || this.options.routingCallback;\n\n    const promises = [];\n\n    this._fireStart();\n\n    const oldValue = this._fireEvents;\n    this._fireEvents = false;\n    this.demoteNodeToWaypoint(node);\n    this._fireEvents = oldValue;\n\n    const nodeContainer = this._getNodeContainer(node);\n\n    const { previousEdge, previousNode } = this._getPrevious(node);\n    const { nextEdge, nextNode } = this._getNext(node);\n\n    if (previousEdge !== undefined && nextEdge !== undefined) {\n      // Intermediate marker\n      nextNode._routeIdPrevious = node._routeIdPrevious;\n      previousEdge._endMarkerId = nextEdge._endMarkerId;\n\n      nextEdge.removeFrom(this._getEdgeContainer(nextEdge));\n      node.removeFrom(nodeContainer);\n      previousEdge.setLatLngs([previousNode.getLatLng(), nextNode.getLatLng()]).setStyle({ dashArray: '4' });\n\n      previousEdge._computation += 1;\n      const currentComputation = previousEdge._computation;\n\n      promises.push(\n        new Promise((resolve, reject) => {\n          callback.call(null, previousNode, nextNode, (err, route, metadata = {}) => {\n            if (err !== null) {\n              reject(err);\n              return;\n            }\n\n            if (previousEdge._computation === currentComputation) {\n              previousEdge.setLatLngs(route).setStyle({ dashArray: null });\n              previousEdge.options.metadata = JSON.parse(JSON.stringify(metadata));\n            }\n\n            resolve({ from: previousNode, to: nextNode, edge: previousEdge });\n          });\n        }),\n      );\n    } else if (previousEdge !== undefined) {\n      // Last marker of path\n      previousNode._routeIdNext = undefined;\n      this._lastNodeId = previousEdge._startMarkerId;\n      previousEdge.removeFrom(this._getEdgeContainer(previousEdge));\n      node.removeFrom(nodeContainer);\n    } else if (nextEdge !== undefined) {\n      // First marker of path\n      nextNode._routeIdPrevious = undefined;\n      this._firstNodeId = nextEdge._endMarkerId;\n      nextEdge.removeFrom(this._getEdgeContainer(nextEdge));\n      node.removeFrom(nodeContainer);\n    } else {\n      // Lonely marker\n      this._lastNodeId = undefined;\n      this._firstNodeId = undefined;\n      node.removeFrom(nodeContainer);\n    }\n\n    return Promise.all(promises)\n      .then((routes) => {\n        this._fireDone({ routes });\n      })\n      .catch((e) => {\n        this._fireFailed(e);\n      });\n  },\n\n  promoteNodeToStopover(node) {\n    if (node._promoted) {\n      return this;\n    }\n\n    if (this._getNodeId(node) === this._firstNodeId) {\n      node.setType('stopover');\n      node._promoted = true;\n      node._demoted = false;\n      return this;\n    }\n\n    this._fireStart();\n\n    const index = this._getNodeContainerIndex(node);\n\n    const nodes = [];\n    const edges = [];\n\n    let currentNode = node;\n    do {\n      nodes.push(currentNode);\n      const { nextEdge, nextNode } = this._getNext(currentNode);\n      if (nextEdge === undefined) {\n        break;\n      }\n\n      nodes.push(currentNode);\n      edges.push(nextEdge);\n\n      currentNode = nextNode;\n    } while (currentNode.options.type !== 'stopover');\n\n    const newNodesContainer = L.featureGroup();\n    const newEdgesContainer = L.featureGroup();\n\n    this._nodesContainers.splice(index + 1, 0, newNodesContainer);\n    this._edgesContainers.splice(index + 1, 0, newEdgesContainer);\n    this._currentColorIndex += 1;\n\n    nodes.forEach((e) => {\n      e.removeFrom(this._getNodeContainer(e)).addTo(newNodesContainer);\n    });\n    edges.forEach((e) => {\n      e.removeFrom(this._getEdgeContainer(e)).addTo(newEdgesContainer);\n    });\n\n    newNodesContainer.setStyle({ colorName: Colors.nameOf(this._currentColorIndex) });\n    newEdgesContainer.setStyle({ color: Colors.rgbOf(this._currentColorIndex) });\n\n    node.setType('stopover');\n    node._promoted = true;\n    node._demoted = false;\n\n    this._fireDone();\n    return this;\n  },\n\n  demoteNodeToWaypoint(node) {\n    if (node._demoted) {\n      return this;\n    }\n\n    const index = this._getNodeContainerIndex(node);\n    if (index === 0) {\n      return this;\n    }\n\n    this._fireStart();\n\n    const nodes = [];\n    const edges = [];\n\n    let currentNode = node;\n    do {\n      nodes.push(currentNode);\n      const { nextEdge, nextNode } = this._getNext(currentNode);\n      if (nextEdge === undefined) {\n        break;\n      }\n\n      nodes.push(currentNode);\n      edges.push(nextEdge);\n\n      currentNode = nextNode;\n    } while (currentNode.options.type !== 'stopover');\n\n    const previousNodesContainer = this._nodesContainers.get(index - 1);\n    const previousEdgesContainer = this._edgesContainers.get(index - 1);\n\n    this._nodesContainers.splice(index, 1);\n    this._edgesContainers.splice(index, 1);\n\n    nodes.forEach((e) => {\n      e.removeFrom(this._getNodeContainer(e)).addTo(previousNodesContainer);\n    });\n    edges.forEach((e) => {\n      e.removeFrom(this._getEdgeContainer(e)).addTo(previousEdgesContainer);\n    });\n\n    const { previousEdge, previousNode } = this._getPrevious(nodes[0]);\n    if (previousEdge !== undefined) {\n      previousNodesContainer.setStyle({ colorName: previousNode.options.colorName });\n      previousEdgesContainer.setStyle({ color: previousEdge.options.color });\n    }\n\n    node.setType('waypoint');\n    node._promoted = false;\n    node._demoted = true;\n\n    this._fireDone();\n    return this;\n  },\n});\n\nmodule.exports = {\n  Track,\n  track(options) {\n    return new Track(options);\n  },\n};\n","const L = require('leaflet');\n\nif (L.Control.EasyBar === undefined) {\n  module.exports = {\n    ToolBar: undefined,\n    toolBar: undefined,\n  };\n} else {\n  const ToolBar = L.Control.EasyBar.extend({\n    options: {\n      mode: null,\n      labelAddMarker: 'Add marker on click',\n      labelInsertMarker: 'Insert marker when clicking on track',\n      labelCloseLoop: 'Close the loop',\n      labelDeleteMarker: 'Delete marker on click',\n      labelPromoteMarker: 'Promote to stopover on click',\n      labelDemoteMarker: 'Demote to waypoint on click',\n      labelClean: 'Remove everything now',\n      labelUndo: 'Undo',\n      labelRedo: 'Redo',\n    },\n\n    initialize(track, options) {\n      this._track = track;\n\n      L.Util.setOptions(this, options);\n      L.Control.EasyBar.prototype.initialize.call(this, this._initializeButtons(), options);\n      this.setMode(this.options.mode);\n\n      this._track.getStepsContainer().on('click', (e) => {\n        if (this.options.mode === 'insert') {\n          const marker = L.TrackDrawer.node(e.latlng);\n          const route = e.layer;\n\n          route.setStyle({ weight: 3 });\n          this._track.insertNode(marker, route);\n          this._bindMarkerEvents(marker);\n        }\n      });\n\n      this._track.getStepsContainer().on('mouseover', (e) => {\n        if (this.options.mode === 'insert') {\n          e.layer.setStyle({ weight: 5 });\n        }\n      });\n\n      this._track.getStepsContainer().on('mouseout', (e) => {\n        if (this.options.mode === 'insert') {\n          e.layer.setStyle({ weight: 3 });\n        }\n      });\n\n      this._track._toolbar = this;\n      this._track._bindMarkerEvents = (marker) => {\n        this._bindMarkerEvents(marker);\n      };\n    },\n\n    setMode(m) {\n      this.options.mode = m;\n      this._addBtn.state('loaded');\n      this._insertBtn.state('loaded');\n      this._deleteBtn.state('loaded');\n      this._promoteBtn.state('loaded');\n      this._demoteBtn.state('loaded');\n\n      if (this._map) {\n        this._map.getContainer().style.cursor = '';\n      }\n\n      switch (this.options.mode) {\n        case 'add': {\n          this._addBtn.state('active');\n          if (this._map) {\n            this._map.getContainer().style.cursor = 'pointer';\n          }\n          break;\n        }\n        case 'insert': {\n          this._insertBtn.state('active');\n          break;\n        }\n        case 'delete': {\n          this._deleteBtn.state('active');\n          break;\n        }\n        case 'promote': {\n          this._promoteBtn.state('active');\n          break;\n        }\n        case 'demote': {\n          this._demoteBtn.state('active');\n          break;\n        }\n        default:\n        // Do nothing\n      }\n\n      return this;\n    },\n\n    _initializeButtons() {\n      const buttons = [];\n      this._addBtn = L.easyButton({\n        id: 'trackdrawer-add',\n        states: [\n          {\n            stateName: 'loaded',\n            icon: 'fa-plus',\n            title: this.options.labelAddMarker,\n            onClick: () => {\n              this.setMode('add');\n            },\n          },\n          {\n            stateName: 'active',\n            icon: 'fa-plus',\n            title: this.options.labelAddMarker,\n            onClick: () => {\n              this.setMode(null);\n            },\n          },\n        ],\n      });\n      buttons.push(this._addBtn);\n      this._insertBtn = L.easyButton({\n        id: 'trackdrawer-insert',\n        states: [\n          {\n            stateName: 'loaded',\n            icon: 'fa-plus-circle',\n            title: this.options.labelInsertMarker,\n            onClick: () => {\n              this.setMode('insert');\n            },\n          },\n          {\n            stateName: 'active',\n            icon: 'fa-plus-circle',\n            title: this.options.labelInsertMarker,\n            onClick: () => {\n              this.setMode(null);\n            },\n          },\n        ],\n      });\n      buttons.push(this._insertBtn);\n      this._closeLoop = L.easyButton({\n        id: 'trackdrawer-closeloop',\n        states: [\n          {\n            stateName: 'loaded',\n            icon: 'fa-magic',\n            title: this.options.labelCloseLoop,\n            onClick: () => {\n              if (this._track.hasNodes(2)) {\n                const nodes = this._track.getNodes();\n                const marker = L.TrackDrawer.node(nodes[0].markers[0].getLatLng()).addTo(this._track);\n                this._bindMarkerEvents(marker);\n              }\n            },\n          },\n        ],\n      });\n      buttons.push(this._closeLoop);\n      this._deleteBtn = L.easyButton({\n        id: 'trackdrawer-delete',\n        states: [\n          {\n            stateName: 'loaded',\n            icon: 'fa-eraser',\n            title: this.options.labelDeleteMarker,\n            onClick: () => {\n              this.setMode('delete');\n            },\n          },\n          {\n            stateName: 'active',\n            icon: 'fa-eraser',\n            title: this.options.labelDeleteMarker,\n            onClick: () => {\n              this.setMode(null);\n            },\n          },\n        ],\n      });\n      buttons.push(this._deleteBtn);\n      this._promoteBtn = L.easyButton({\n        id: 'trackdrawer-promote',\n        states: [\n          {\n            stateName: 'loaded',\n            icon: 'fa-pause-circle',\n            title: this.options.labelPromoteMarker,\n            onClick: () => {\n              this.setMode('promote');\n            },\n          },\n          {\n            stateName: 'active',\n            icon: 'fa-pause-circle',\n            title: this.options.labelPromoteMarker,\n            onClick: () => {\n              this.setMode(null);\n            },\n          },\n        ],\n      });\n      buttons.push(this._promoteBtn);\n      this._demoteBtn = L.easyButton({\n        id: 'trackdrawer-demote',\n        states: [\n          {\n            stateName: 'loaded',\n            icon: 'fa-map-signs',\n            title: this.options.labelDemoteMarker,\n            onClick: () => {\n              this.setMode('demote');\n            },\n          },\n          {\n            stateName: 'active',\n            icon: 'fa-map-signs',\n            title: this.options.labelDemoteMarker,\n            onClick: () => {\n              this.setMode(null);\n            },\n          },\n        ],\n      });\n      buttons.push(this._demoteBtn);\n      this._cleanBtn = L.easyButton({\n        id: 'trackdrawer-clean',\n        states: [\n          {\n            icon: 'fa-trash',\n            title: this.options.labelClean,\n            onClick: () => {\n              this._track.clean();\n            },\n          },\n        ],\n      });\n      buttons.push(this._cleanBtn);\n\n      if (this._track.options.undoable) {\n        this._undoBtn = L.easyButton({\n          id: 'trackdrawer-undo',\n          states: [\n            {\n              icon: 'fa-undo',\n              title: this.options.labelUndo,\n              onClick: () => {\n                this._track.undo((latlng) => {\n                  const marker = L.TrackDrawer.node(latlng);\n                  this._bindMarkerEvents(marker);\n                  return marker;\n                });\n              },\n            },\n          ],\n        });\n        buttons.push(this._undoBtn);\n        this._redoBtn = L.easyButton({\n          id: 'trackdrawer-redo',\n          states: [\n            {\n              icon: 'fa-repeat',\n              title: this.options.labelRedo,\n              onClick: () => {\n                this._track.redo((latlng) => {\n                  const marker = L.TrackDrawer.node(latlng);\n                  this._bindMarkerEvents(marker);\n                  return marker;\n                });\n              },\n            },\n          ],\n        });\n        buttons.push(this._redoBtn);\n      }\n\n      this._track.on('TrackDrawer:start', () => {\n        if (this._track.options.undoable) {\n          this._undoBtn.disable();\n          this._redoBtn.disable();\n        }\n      });\n\n      this._track.on('TrackDrawer:done', () => {\n        if (this._track.hasNodes(2)) {\n          this._closeLoop.enable();\n        } else {\n          this._closeLoop.disable();\n        }\n\n        if (this._track.hasNodes()) {\n          this._insertBtn.enable();\n          this._deleteBtn.enable();\n          this._promoteBtn.enable();\n          this._demoteBtn.enable();\n          this._cleanBtn.enable();\n        } else {\n          this._insertBtn.disable();\n          this._deleteBtn.disable();\n          this._promoteBtn.disable();\n          this._demoteBtn.disable();\n          this._cleanBtn.disable();\n        }\n\n        if (this._track.options.undoable) {\n          if (this._track.isUndoable()) {\n            this._undoBtn.enable();\n          } else {\n            this._undoBtn.disable();\n          }\n          if (this._track.isRedoable()) {\n            this._redoBtn.enable();\n          } else {\n            this._redoBtn.disable();\n          }\n        }\n      });\n\n      return buttons;\n    },\n\n    _bindMarkerEvents(marker) {\n      marker.on('click', this._onMarkerClickHandler);\n      marker.on('mouseover', this._onMarkerMouseOverHandler);\n      marker.on('mouseout', this._onMarkerMouseOutHandler);\n      return this;\n    },\n\n    onAdd(map) {\n      this._onMapClickHandler = (e) => {\n        if (this.options.mode === 'add') {\n          const marker = L.TrackDrawer.node(e.latlng).addTo(this._track);\n          this._bindMarkerEvents(marker);\n        }\n      };\n\n      this._onMarkerClickHandler = (e) => {\n        const marker = e.target;\n        switch (this.options.mode) {\n          case 'delete': {\n            const { previousEdge } = this._track._getPrevious(marker);\n            const { nextEdge } = this._track._getNext(marker);\n\n            if (previousEdge) previousEdge.setStyle({ weight: 3 });\n            if (nextEdge) nextEdge.setStyle({ weight: 3 });\n\n            this._track.removeNode(marker);\n            break;\n          }\n          case 'promote': {\n            this._track.promoteNodeToStopover(marker);\n            break;\n          }\n          case 'demote': {\n            this._track.demoteNodeToWaypoint(marker);\n            break;\n          }\n          default:\n        }\n      };\n\n      this._onMarkerMouseOverHandler = (e) => {\n        if (this.options.mode === 'delete' || this.options.mode === 'promote' || this.options.mode === 'demote') {\n          const marker = e.target;\n          const { previousEdge } = this._track._getPrevious(marker);\n          const { nextEdge } = this._track._getNext(marker);\n\n          if (previousEdge) previousEdge.setStyle({ weight: 5 });\n          if (nextEdge) nextEdge.setStyle({ weight: 5 });\n        }\n      };\n\n      this._onMarkerMouseOutHandler = (e) => {\n        const marker = e.target;\n        const { previousEdge } = this._track._getPrevious(marker);\n        const { nextEdge } = this._track._getNext(marker);\n\n        if (previousEdge) previousEdge.setStyle({ weight: 3 });\n        if (nextEdge) nextEdge.setStyle({ weight: 3 });\n      };\n\n      L.DomEvent.on(map, 'click', this._onMapClickHandler);\n      return L.Control.EasyBar.prototype.onAdd.call(this, map);\n    },\n\n    onRemove(map) {\n      if (this.options.mode === 'add') map.getContainer().style.cursor = '';\n\n      L.DomEvent.off(map, 'click', this._onMapClickHandler);\n      this._track.getNodes().forEach((nodes) => {\n        nodes.markers.forEach((marker) => {\n          marker.off('click', this._onMarkerClickHandler);\n          marker.off('mouseover', this._onMarkerMouseOverHandler);\n          marker.off('mouseout', this._onMarkerMouseOutHandler);\n        });\n      });\n    },\n  });\n\n  module.exports = {\n    ToolBar,\n    toolBar(track, options) {\n      return new ToolBar(track, options);\n    },\n  };\n}\n","const L = require('leaflet');\n\nif (L.Control.EasyBar === undefined) {\n  module.exports = {\n    TraceModeBar: undefined,\n    traceModeBar: undefined,\n  };\n} else {\n  const TraceModeBar = L.Control.EasyBar.extend({\n    options: {\n      mode: null,\n    },\n\n    initialize(track, modes, options) {\n      this._track = track;\n      this._buttonsMap = {};\n\n      L.Control.EasyBar.prototype.initialize.call(this, this._initializeButtons(modes), options);\n      this.setMode(this.options.mode);\n    },\n\n    setMode(m) {\n      const ids = Object.keys(this._buttonsMap);\n      let newMode = m;\n      if (newMode === null) {\n        const idx = this.options.mode === ids[0] ? 1 : 0;\n        newMode = ids[idx];\n      }\n\n      this.options.mode = newMode;\n      ids.forEach((key) => {\n        this._buttonsMap[key].btn.state('loaded');\n      });\n\n      this._buttonsMap[newMode].btn.state('active');\n      this._track.setOptions({\n        router: this._buttonsMap[newMode].router,\n        routingCallback: this._buttonsMap[newMode].routingCallback,\n      });\n\n      return this;\n    },\n\n    _initializeButtons(modes) {\n      const buttons = [];\n      modes.forEach((m) => {\n        const btn = L.easyButton({\n          id: `trackdrawer-mode-${m.id}`,\n          states: [\n            {\n              stateName: 'loaded',\n              icon: m.icon,\n              title: m.name,\n              onClick: () => {\n                this.setMode(m.id);\n              },\n            },\n            {\n              stateName: 'active',\n              icon: m.icon,\n              title: m.name,\n              onClick: () => {\n                this.setMode(null);\n              },\n            },\n          ],\n        });\n        buttons.push(btn);\n        this._buttonsMap[m.id] = {\n          router: m.router,\n          routingCallback: m.routingCallback,\n          btn,\n        };\n      });\n\n      return buttons;\n    },\n  });\n\n  module.exports = {\n    TraceModeBar,\n    traceModeBar(track, modes, options) {\n      return new TraceModeBar(track, modes, options);\n    },\n  };\n}\n","const L = require('leaflet');\n\nconst Node = L.Marker.extend({\n  _routeIdPrevious: undefined,\n  _routeIdNext: undefined,\n  _promoted: false,\n  _demoted: true,\n\n  options: {\n    type: 'waypoint', // Or 'stopover',\n    colorName: 'blue',\n    opacity: 1,\n    draggable: true,\n    metadata: {},\n  },\n\n  initialize(latlng, options) {\n    L.Marker.prototype.initialize.call(this, latlng, options);\n    L.setOptions(this, options);\n    this.setType(this.options.type);\n    this.options.metadata = JSON.parse(JSON.stringify(this.options.metadata));\n  },\n\n  setType(type) {\n    this.options.type = type;\n\n    if (type === 'stopover') {\n      this.setIcon(\n        L.AwesomeMarkers.icon({\n          icon: 'pause-circle',\n          markerColor: this.options.colorName,\n          prefix: 'fa',\n        }),\n      );\n    } else {\n      this.setIcon(\n        L.AwesomeMarkers.icon({\n          icon: 'map-signs',\n          markerColor: this.options.colorName,\n          prefix: 'fa',\n        }),\n      );\n    }\n    return this;\n  },\n\n  setStyle(style) {\n    L.Util.setOptions(this, style);\n\n    if ('colorName' in style) {\n      // Colors is set only via the icon and there's no setter on L.AwesomeMarkers\n      this.setType(this.options.type);\n    }\n    if ('opacity' in style) {\n      this.setOpacity(this.options.opacity);\n    }\n\n    return this;\n  },\n});\n\nmodule.exports = {\n  Node,\n  node(latlng, options) {\n    return new Node(latlng, options);\n  },\n};\n","const L = require('leaflet');\n\n/**\n * Splits an array of LatLng objects every X meters\n * @param {L.LatLng[]} latlngs Polyline to split\n * @param {int} distance Max. distance of each segment of the polyline (in meters)\n * @returns L.LatLng[][]\n */\nfunction splitLatLngs(latlngs, distance = 100) {\n  if (distance <= 0) throw new Error('`distance` must be positive');\n  if (latlngs.length === 0) return [[]];\n\n  let result = [];\n  if (Array.isArray(latlngs[0])) {\n    for (let j = 0; j < latlngs.length; j += 1) {\n      result = result.concat(splitLatLngs(latlngs[j], distance));\n    }\n\n    return result;\n  }\n\n  let tmp = latlngs.splice(0, 1);\n  while (latlngs.length > 0) {\n    const latlng = L.latLng(latlngs.splice(0, 1)[0]);\n    tmp.push(latlng);\n    if (latlng.distanceTo(tmp[0]) > distance) {\n      result.push(tmp);\n      tmp = [latlng];\n    }\n  }\n  result.push(tmp);\n\n  return result;\n}\n\n/**\n * Splits a L.Polyline object every X meters\n * @param {L.Polyline} polyline Polyline to split\n * @param {int} distance Max. distance of each segment of the polyline (in meters)\n * @returns L.Polyline[]\n */\nfunction splitPolyline(polyline, distance = 100) {\n  return splitLatLngs(polyline.getLatLngs(), distance).map((a) => L.polyline(a));\n}\n\nfunction featureGroupToPolylines(featureGroup) {\n  return featureGroup.getLayers().filter((layer) => layer instanceof L.Polyline);\n}\n\nfunction featureGroupToLatLngs(featureGroup) {\n  return featureGroupToPolylines(featureGroup).map((layer) => [layer.getLatLngs(), layer.feature.properties]);\n}\n\nmodule.exports = {\n  splitPolyline,\n  splitLatLngs,\n  featureGroupToPolylines,\n  featureGroupToLatLngs,\n};\n","/* eslint-disable arrow-parens */\nconst L = require('leaflet');\nconst corslite = require('@mapbox/corslite');\nconst { Track } = require('./Track');\nconst latlngutils = require('./LatLngUtils');\n\nTrack.include({\n  _createFileLoader() {\n    this._fileLoader = L.FileLayer.fileLoader(null, {\n      addToMap: false,\n      fileSizeLimit: this.options.fileSizeLimit || 1024,\n      formats: this.options.fileFormat || ['.geojson', '.json', '.kml', '.gpx'],\n    });\n  },\n\n  createFileLoaderControl(insertWaypoints = false) {\n    this._fileLoaderController = L.Control.fileLayerLoad({\n      addToMap: false,\n      fileSizeLimit: this.options.fileSizeLimit || 1024,\n      formats: this.options.fileFormat || ['.geojson', '.json', '.kml', '.gpx'],\n    }).addTo(this._map);\n\n    this._fileLoaderController.loader.on('data:loaded', (event) => {\n      this._dataLoadedHandler(event.layer, insertWaypoints);\n    });\n\n    return this._fileLoaderController;\n  },\n\n  async _dataLoadedHandler(layer, insertWaypoints = false) {\n    this._fireStart();\n\n    const oldValue = this._fireEvents;\n    this._fireEvents = false;\n    this.clean();\n\n    const latlngs = insertWaypoints\n      ? latlngutils.featureGroupToLatLngs(layer).map(l => [latlngutils.splitLatLngs(l[0]), l[1]])\n      : latlngutils.featureGroupToLatLngs(layer).map(l => [[l[0]], l[1]]);\n\n    let lastMarker;\n    const hasToolbar = this._toolbar !== undefined;\n    /* eslint-disable no-await-in-loop */\n    for (let i = 0; i < latlngs.length; i += 1) {\n      const properties = latlngs[i][1];\n      for (let j = 0; j < latlngs[i][0].length; j += 1) {\n        const l = latlngs[i][0][j];\n        if (l.length > 0) {\n          if (lastMarker === undefined) {\n            lastMarker = L.TrackDrawer.node(l[0]);\n            await this.addNode(lastMarker, undefined, true);\n            if (hasToolbar) this._bindMarkerEvents(lastMarker);\n          }\n\n          lastMarker = L.TrackDrawer.node(l[l.length - 1], {\n            type: j === latlngs[i][0].length - 1 ? 'stopover' : 'waypoint',\n          });\n          await this.addNode(\n            lastMarker,\n            (_n1, _n2, cb) => {\n              cb(null, l, properties);\n            },\n            true,\n          );\n          if (hasToolbar) this._bindMarkerEvents(lastMarker);\n        }\n      }\n    }\n    /* eslint-enable no-await-in-loop */\n\n    this._fireEvents = oldValue;\n    this._fireDone();\n  },\n\n  loadData(data, name, ext, insertWaypoints = false) {\n    return new Promise((resolve, reject) => {\n      this._fileLoader.on('data:loaded', async (event) => {\n        await this._dataLoadedHandler(event.layer, insertWaypoints);\n        this._fileLoader.off();\n        resolve();\n      });\n      this._fileLoader.on('data:error', (error) => {\n        this._fileLoader.off();\n        reject(error.error);\n      });\n\n      this._fileLoader.loadData(data, name, ext);\n    });\n  },\n\n  loadFile(file, insertWaypoints = false) {\n    return new Promise((resolve, reject) => {\n      this._fileLoader.on('data:loaded', async (event) => {\n        await this._dataLoadedHandler(event.layer, insertWaypoints);\n        this._fileLoader.off();\n        resolve();\n      });\n      this._fileLoader.on('data:error', (error) => {\n        this._fileLoader.off();\n        reject(error.error);\n      });\n\n      this._fileLoader.load(file);\n    });\n  },\n\n  loadUrl(url, useProxy = false, insertWaypoints = false) {\n    const filename = url.split('/').pop();\n    const ext = filename.split('.').pop();\n\n    const proxiedUrl = useProxy ? `fetch.php?url=${encodeURIComponent(url)}` : url;\n\n    return new Promise((resolve, reject) => {\n      corslite(\n        proxiedUrl,\n        (err, resp) => {\n          if (!err) {\n            try {\n              this._fileLoader.on('data:loaded', async (event) => {\n                await this._dataLoadedHandler(event.layer, insertWaypoints);\n                this._fileLoader.off();\n                resolve();\n              });\n              this._fileLoader.on('data:error', (error) => {\n                this._fileLoader.off();\n                reject(error.error);\n              });\n              this._fileLoader.loadData(resp.responseText, filename, ext);\n            } catch (ex) {\n              reject(ex);\n            }\n          } else if (err.responseText) {\n            try {\n              // Check if response is JSON\n              const data = JSON.parse(err.responseText);\n              reject(new Error(data.error));\n            } catch (ex) {\n              reject(new Error(err.statusText));\n            }\n          } else if (err.statusText) {\n            reject(new Error(err.statusText));\n          } else {\n            reject(new Error(err));\n          }\n        },\n        false,\n      );\n    });\n  },\n});\n\nTrack.addInitHook('_createFileLoader');\n","const L = require('leaflet');\nconst { Track, track } = require('./Track');\nconst { ToolBar, toolBar } = require('./ToolBar');\nconst { TraceModeBar, traceModeBar } = require('./TraceModeBar');\nconst LayerContainer = require('./LayerContainer');\nconst { Node, node } = require('./Node');\nconst { Edge, edge } = require('./Edge');\nconst colors = require('./Colors');\nrequire('./Loader');\nconst latlngutils = require('./LatLngUtils');\n\n/** @module L.TrackDrawer */\nL.TrackDrawer = {\n  Track,\n  track,\n  ToolBar,\n  toolBar,\n  TraceModeBar,\n  traceModeBar,\n  LayerContainer,\n  Node,\n  node,\n  Edge,\n  edge,\n  colors,\n  latlngutils,\n};\n\nmodule.exports = L.TrackDrawer;\n"],"names":["runtime","exports","undefined","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","_invoke","state","GenStateSuspendedStart","method","arg","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","done","GenStateSuspendedYield","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","invoke","resolve","reject","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","asyncGeneratorStep","gen","_next","_throw","args","arguments","apply","colorMap","red","orange","green","blue","purple","darkred","darkblue","darkgreen","darkpurple","cadetblue","lightred","beige","lightgreen","lightblue","pink","white","lightgray","gray","black","colors","freeze","nameOf","idx","rgbOf","nameToRgb","rgbToName","rgb","find","L","Evented","extend","initialize","parent","_parent","f","featureGroup","addTo","addEventParent","_elements","get","splice","ret","x","removeFrom","_this","removeEventParent","Array","cb","clean","clearLayers","getLayer","id","parentLayer","getLayerId","layer","hasLayer","getLayerIndex","findIndex","Edge","Polyline","_startMarkerId","_endMarkerId","_promoted","_demoted","_computation","options","metadata","latlngs","setOptions","JSON","parse","stringify","edge","require$$0","encodeLatLngs","array","size","lat","lng","decodeLatLngs","latLng","encodeLatLng","latlng","decodeLatLng","Track","LayerGroup","routingCallback","router","debug","undoable","undoDepth","_getPrevious","node","previousEdge","_getEdge","_routeIdPrevious","previousNode","_getNode","_getNext","nextEdge","_routeIdNext","nextNode","_getNodeId","_nodesContainers","_getEdgeId","_edgesContainers","_getNodeContainerIndex","_getNodeContainer","_getEdgeContainerIndex","_getEdgeContainer","LayerContainer","_firstNodeId","_lastNodeId","_currentColorIndex","_fireEvents","_computing","_states","_currentStateIndex","getState","previousMarker","marker","route","Routing","waypoint","getLatLng","coordinates","hasNodes","count","counter","container","group","getLayers","getNodes","nodes","markers","getNodesContainer","getSteps","steps","edges","getStepsContainer","getBounds","bounds","latLngBounds","getLatLngs","hasTrackStats","TrackStats","currentNode","l","_this2","e","cache","getAll","_stopoversToGeoJSON","stopovers","features","_this3","properties","index","geometry","z","_edgesToFlatGeoJSON","feature","_this4","e2","_edgesToGeoJSON","_c","_this5","toGeoJSON","exportStopovers","exportAsFlat","geojson","version","start","_this6","end","_fireStart","payload","fire","_fireDone","_pushState","_fireFailed","message","refreshEdges","callback","_this7","oldValue","promises","onMoveNode","all","_createNode","TrackDrawer","restoreState","nodeCallback","_this8","routes","segment","j","addNode","from","to","m","promoteNodeToStopover","_undoing","undo","_this9","isUndoable","isRedoable","redo","_this10","addLayer","Marker","_createEdge","edgesContainer","color","Colors","colorName","dashArray","on","startNodeId","endNodeId","setTooltipContent","_this11","bindTooltip","_prepareNode","nodesContainer","_this12","setStyle","draggable","_onDragStartNode","target","_onDragNode","skipChecks","equals","lastNodeId","_this13","currentComputation","setLatLng","setLatLngs","insertNode","startMarker","endMarker","edge1","edge2","currentComputation1","currentComputation2","promise1","route1","metadata1","promise2","route2","metadata2","_this14","_this15","removeNode","demoteNodeToWaypoint","nodeContainer","_this16","setType","newNodesContainer","newEdgesContainer","_this17","previousNodesContainer","previousEdgesContainer","_this18","track","Control","EasyBar","ToolBar","toolBar","mode","labelAddMarker","labelInsertMarker","labelCloseLoop","labelDeleteMarker","labelPromoteMarker","labelDemoteMarker","labelClean","labelUndo","labelRedo","_track","Util","_initializeButtons","setMode","weight","_bindMarkerEvents","_toolbar","_addBtn","_insertBtn","_deleteBtn","_promoteBtn","_demoteBtn","_map","getContainer","style","cursor","buttons","easyButton","states","stateName","icon","title","onClick","_closeLoop","_cleanBtn","_undoBtn","_redoBtn","disable","enable","_onMarkerClickHandler","_onMarkerMouseOverHandler","_onMarkerMouseOutHandler","onAdd","map","_onMapClickHandler","DomEvent","onRemove","off","TraceModeBar","traceModeBar","modes","_buttonsMap","ids","newMode","btn","Node","opacity","setIcon","AwesomeMarkers","markerColor","prefix","setOpacity","splitLatLngs","distance","isArray","concat","tmp","distanceTo","featureGroupToPolylines","filter","splitPolyline","polyline","a","featureGroupToLatLngs","include","_createFileLoader","_fileLoader","FileLayer","fileLoader","addToMap","fileSizeLimit","formats","fileFormat","createFileLoaderControl","insertWaypoints","_fileLoaderController","fileLayerLoad","loader","event","_dataLoadedHandler","latlngutils","hasToolbar","lastMarker","_n1","_n2","loadData","data","ext","loadFile","file","load","loadUrl","url","useProxy","filename","split","proxiedUrl","encodeURIComponent","corslite","resp","responseText","ex","statusText","addInitHook","require$$1","require$$2","require$$3","require$$4"],"mappings":"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"}