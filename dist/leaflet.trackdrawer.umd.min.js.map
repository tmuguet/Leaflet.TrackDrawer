{"version":3,"file":"leaflet.trackdrawer.umd.min.js","sources":["../src/Colors.js","../src/LayerContainer.js","../src/Edge.js","../src/Track.js","../src/ToolBar.js","../src/TraceModeBar.js","../src/Node.js","../src/LatLngUtils.js","../src/Loader.js","../src/index.js"],"sourcesContent":["const colorMap = {\n  red: '#D63E2A',\n  orange: '#F59630',\n  green: '#72B026',\n  blue: '#38AADD',\n  purple: '#D252B9',\n  darkred: '#A23336',\n  darkblue: '#0067A3',\n  darkgreen: '#728224',\n  darkpurple: '#5B396B',\n  cadetblue: '#436978',\n  lightred: '#FF8E7F',\n  beige: '#FFCB92',\n  lightgreen: '#BBF970',\n  lightblue: '#8ADAFF',\n  pink: '#FF91EA',\n  white: '#FBFBFB',\n  lightgray: '#A3A3A3',\n  gray: '#575757',\n  black: '#303030',\n};\nconst colors = [\n  'blue',\n  'green',\n  'orange',\n  'purple',\n  'red',\n  'darkblue',\n  'darkpurple',\n  'lightblue',\n  'lightgreen',\n  'beige',\n  'pink',\n  'lightred',\n]; // Colors supported by Leaflet AwesomeMarkers\n\nObject.freeze(colorMap);\nObject.freeze(colors);\n\nmodule.exports = {\n  nameOf(idx) {\n    return colors[idx % colors.length];\n  },\n\n  rgbOf(idx) {\n    return colorMap[this.nameOf(idx)];\n  },\n\n  nameToRgb(name) {\n    return colorMap[name];\n  },\n\n  rgbToName(rgb) {\n    return Object.keys(colorMap).find((key) => colorMap[key] === rgb);\n  },\n};\n","const L = require('leaflet');\n\nmodule.exports = L.Evented.extend({\n  initialize(parent) {\n    this._parent = parent;\n    const f = L.featureGroup()\n      .addTo(parent)\n      .addEventParent(this);\n    this._elements = [f];\n    this.length = 1;\n  },\n\n  get(i) {\n    const idx = i < 0 ? this._elements.length + i : i;\n    return this._elements[idx];\n  },\n\n  /* eslint-disable prefer-rest-params */\n  splice() {\n    const ret = this._elements.splice(...arguments);\n    ret.forEach((x) => x.removeFrom(this._parent).removeEventParent(this));\n\n    if (arguments.length > 2) {\n      const args = Array.prototype.slice.call(arguments, 2);\n      args.forEach((x) => {\n        x.addTo(this._parent).addEventParent(this);\n      });\n    }\n\n    this.length = this._elements.length;\n    return ret;\n  },\n  /* eslint-enable prefer-rest-params */\n\n  forEach(cb) {\n    this._elements.forEach(cb);\n  },\n\n  clean() {\n    this._elements[0].clearLayers();\n    this.splice(1);\n  },\n\n  getLayer(id) {\n    const parentLayer = this._elements.find((x) => x.getLayer(id) !== undefined);\n    return parentLayer !== undefined ? parentLayer.getLayer(id) : undefined;\n  },\n  getLayerId(layer) {\n    const parentLayer = this._elements.find((x) => x.hasLayer(layer));\n    return parentLayer !== undefined ? parentLayer.getLayerId(layer) : undefined;\n  },\n  getLayerIndex(layer) {\n    return this._elements.findIndex((x) => x.hasLayer(layer));\n  },\n});\n","const L = require('leaflet');\n\nconst Edge = L.Polyline.extend({\n  _startMarkerId: undefined,\n  _endMarkerId: undefined,\n  _promoted: false,\n  _demoted: true,\n  _computation: 0,\n\n  options: { metadata: {} },\n\n  initialize(latlngs, options) {\n    L.Polyline.prototype.initialize.call(this, latlngs, options);\n    L.setOptions(this, options);\n    this.options.metadata = JSON.parse(JSON.stringify(this.options.metadata));\n  },\n});\n\nmodule.exports = {\n  Edge,\n  edge(latlngs, options) {\n    return new Edge(latlngs, options);\n  },\n};\n","const L = require('leaflet');\nconst Colors = require('./Colors');\nconst LayerContainer = require('./LayerContainer');\nconst { Edge } = require('./Edge');\n\nfunction encodeLatLngs(latlngs) {\n  const array = [];\n  const size = latlngs.length;\n  for (let i = 0; i < size; i += 1) {\n    array.push(latlngs[i].lat);\n    array.push(latlngs[i].lng);\n  }\n  return array;\n\n  /* polyline with precision of 8 seems broken\n\n    var array = latlngs.map(function(x) {\n      return [x.lat, x.lng];\n    });\n\n    return polyline.encode(array, 8); //\n    */\n}\n\nfunction decodeLatLngs(latlngs) {\n  const array = [];\n  const size = latlngs.length;\n  for (let i = 0; i < size; i += 2) {\n    array.push(L.latLng(latlngs[i], latlngs[i + 1]));\n  }\n  return array;\n\n  /* polyline with precision of 8 seems broken\n\n    var decoded = polyline.decode(latlngs, 8);\n\n    return decoded.map(function(x) {\n      return L.latLng(x[0], x[1]);\n    });\n    */\n}\n\nfunction encodeLatLng(latlng) {\n  return [latlng.lat, latlng.lng];\n}\n\nfunction decodeLatLng(latlng) {\n  return L.latLng(latlng[0], latlng[1]);\n}\n\nconst Track = L.LayerGroup.extend({\n  options: {\n    routingCallback: undefined,\n    router: undefined,\n    debug: false,\n    undoable: true,\n    undoDepth: 30,\n  },\n\n  _getPrevious(node) {\n    const previousEdge = node !== undefined ? this._getEdge(node._routeIdPrevious) : undefined;\n    const previousNode = previousEdge !== undefined ? this._getNode(previousEdge._startMarkerId) : undefined;\n    return { previousEdge, previousNode };\n  },\n\n  _getNext(node) {\n    const nextEdge = node !== undefined ? this._getEdge(node._routeIdNext) : undefined;\n    const nextNode = nextEdge !== undefined ? this._getNode(nextEdge._endMarkerId) : undefined;\n    return { nextEdge, nextNode };\n  },\n\n  _getNodeId(node) {\n    return this._nodesContainers.getLayerId(node);\n  },\n  _getEdgeId(edge) {\n    return this._edgesContainers.getLayerId(edge);\n  },\n  _getNode(id) {\n    return this._nodesContainers.getLayer(id);\n  },\n  _getEdge(id) {\n    return this._edgesContainers.getLayer(id);\n  },\n  _getNodeContainerIndex(node) {\n    return this._nodesContainers.getLayerIndex(node);\n  },\n  _getNodeContainer(node) {\n    return this._nodesContainers.get(this._getNodeContainerIndex(node));\n  },\n  _getEdgeContainerIndex(edge) {\n    return this._edgesContainers.getLayerIndex(edge);\n  },\n  _getEdgeContainer(edge) {\n    return this._edgesContainers.get(this._getEdgeContainerIndex(edge));\n  },\n\n  initialize(options) {\n    this.setOptions(options);\n    L.LayerGroup.prototype.initialize.call(this);\n\n    this._nodesContainers = new LayerContainer(this);\n    this._edgesContainers = new LayerContainer(this);\n    this._firstNodeId = undefined;\n    this._lastNodeId = undefined;\n    this._currentColorIndex = 0;\n    this._fireEvents = true;\n    this._computing = 0;\n\n    this._states = null;\n    this._currentStateIndex = null;\n\n    if (this.options.undoable) {\n      this._states = [];\n      this._states.push(this.getState());\n      this._currentStateIndex = 0;\n    }\n  },\n\n  setOptions(options) {\n    L.setOptions(this, options);\n\n    if (this.options.router !== undefined) {\n      this.options.routingCallback = (previousMarker, marker, done) => {\n        this.options.router.route(\n          [L.Routing.waypoint(previousMarker.getLatLng()), L.Routing.waypoint(marker.getLatLng())],\n          (err, result) => {\n            done(err, result ? result[0].coordinates : null, {});\n          },\n        );\n      };\n    }\n  },\n\n  hasNodes(count = 1) {\n    let counter = 0;\n    this._nodesContainers.forEach((container) => {\n      const group = container.getLayers();\n      counter += group.length;\n    });\n    return counter >= count;\n  },\n\n  getNodes() {\n    const nodes = [];\n\n    this._nodesContainers.forEach((container) => {\n      const group = container.getLayers();\n      if (group.length > 0) nodes.push({ container, markers: group });\n    });\n\n    return nodes;\n  },\n  getNodesContainer() {\n    return this._nodesContainers;\n  },\n\n  getSteps() {\n    const steps = [];\n\n    this._edgesContainers.forEach((container) => {\n      const group = container.getLayers();\n      if (group.length > 0) steps.push({ container, edges: group });\n    });\n\n    return steps;\n  },\n  getStepsContainer() {\n    return this._edgesContainers;\n  },\n\n  getBounds() {\n    const bounds = L.latLngBounds([]);\n\n    this._nodesContainers.forEach((container) => {\n      bounds.extend(container.getBounds());\n    });\n\n    this._edgesContainers.forEach((container) => {\n      bounds.extend(container.getBounds());\n    });\n    return bounds;\n  },\n\n  getLatLngs() {\n    const hasTrackStats = L.TrackStats !== undefined;\n    const latlngs = [];\n\n    let currentNode = this._getNode(this._firstNodeId);\n    this._nodesContainers.forEach(() => {\n      const l = [];\n      do {\n        const { nextEdge, nextNode } = this._getNext(currentNode);\n        if (currentNode === undefined || nextEdge === undefined) {\n          break;\n        }\n\n        nextEdge.getLatLngs().forEach((e) => {\n          l.push(hasTrackStats ? L.TrackStats.cache.getAll(e) : e);\n        });\n\n        currentNode = nextNode;\n      } while (currentNode.options.type !== 'stopover');\n\n      latlngs.push(JSON.parse(JSON.stringify(l)));\n    });\n\n    return latlngs;\n  },\n\n  _stopoversToGeoJSON() {\n    const stopovers = [];\n    const features = [];\n\n    let currentNode = this._getNode(this._firstNodeId);\n\n    if (currentNode !== undefined) {\n      stopovers.push(currentNode);\n    }\n    this._nodesContainers.forEach(() => {\n      do {\n        const { nextEdge, nextNode } = this._getNext(currentNode);\n        if (currentNode === undefined || nextEdge === undefined) {\n          break;\n        }\n\n        currentNode = nextNode;\n      } while (currentNode.options.type !== 'stopover');\n\n      if (currentNode !== undefined) {\n        stopovers.push(currentNode);\n      }\n    });\n\n    const hasTrackStats = L.TrackStats !== undefined;\n    stopovers.forEach((node, idx) => {\n      const e = hasTrackStats ? L.TrackStats.cache.getAll(node.getLatLng()) : node.getLatLng();\n      const properties = JSON.parse(JSON.stringify(node.options.metadata));\n      properties.index = idx;\n\n      features.push({\n        type: 'Feature',\n        properties,\n        geometry: {\n          type: 'Point',\n          coordinates: 'z' in e && e.z !== null ? [e.lng, e.lat, e.z] : [e.lng, e.lat],\n        },\n      });\n    });\n\n    return features;\n  },\n\n  _edgesToFlatGeoJSON() {\n    const hasTrackStats = L.TrackStats !== undefined;\n    const feature = {\n      type: 'Feature',\n      properties: { index: 0 },\n      geometry: {\n        type: 'LineString',\n        coordinates: [],\n      },\n    };\n\n    let currentNode = this._getNode(this._firstNodeId);\n    this._nodesContainers.forEach(() => {\n      do {\n        const { nextEdge, nextNode } = this._getNext(currentNode);\n        if (currentNode === undefined || nextEdge === undefined) {\n          break;\n        }\n\n        nextEdge.getLatLngs().forEach((e) => {\n          const e2 = hasTrackStats ? L.TrackStats.cache.getAll(e) : e;\n          feature.geometry.coordinates.push('z' in e2 && e2.z !== null ? [e2.lng, e2.lat, e2.z] : [e2.lng, e2.lat]);\n        });\n\n        currentNode = nextNode;\n      } while (currentNode.options.type !== 'stopover');\n    });\n\n    return feature;\n  },\n\n  _edgesToGeoJSON() {\n    const hasTrackStats = L.TrackStats !== undefined;\n    const features = [];\n\n    let currentNode = this._getNode(this._firstNodeId);\n    this._nodesContainers.forEach((_c, idx) => {\n      do {\n        const { nextEdge, nextNode } = this._getNext(currentNode);\n        if (currentNode === undefined || nextEdge === undefined) {\n          break;\n        }\n\n        const properties = JSON.parse(JSON.stringify(nextEdge.options.metadata));\n        properties.index = idx;\n\n        const feature = {\n          type: 'Feature',\n          properties,\n          geometry: {\n            type: 'LineString',\n            coordinates: [],\n          },\n        };\n\n        nextEdge.getLatLngs().forEach((e) => {\n          const e2 = hasTrackStats ? L.TrackStats.cache.getAll(e) : e;\n          feature.geometry.coordinates.push('z' in e2 && e2.z !== null ? [e2.lng, e2.lat, e2.z] : [e2.lng, e2.lat]);\n        });\n\n        features.push(feature);\n\n        currentNode = nextNode;\n      } while (currentNode.options.type !== 'stopover');\n    });\n\n    return features;\n  },\n\n  toGeoJSON(exportStopovers = true, exportAsFlat = false) {\n    const geojson = {\n      type: 'FeatureCollection',\n      features: [],\n    };\n\n    if (exportStopovers) {\n      this._stopoversToGeoJSON().forEach((f) => geojson.features.push(f));\n    }\n\n    if (exportAsFlat) {\n      geojson.features.push(this._edgesToFlatGeoJSON());\n    } else {\n      this._edgesToGeoJSON().forEach((f) => geojson.features.push(f));\n    }\n\n    return geojson;\n  },\n\n  getState() {\n    const state = [\n      {\n        version: 2,\n        start: undefined,\n        metadata: undefined,\n      },\n    ];\n    let currentNode = this._getNode(this._firstNodeId);\n\n    if (currentNode !== undefined) {\n      state[0].start = encodeLatLng(currentNode.getLatLng());\n      state[0].metadata = JSON.parse(JSON.stringify(currentNode.options.metadata));\n    }\n\n    this._nodesContainers.forEach(() => {\n      const group = [];\n\n      do {\n        const { nextEdge, nextNode } = this._getNext(currentNode);\n        if (currentNode === undefined || nextEdge === undefined) {\n          break;\n        }\n\n        group.push({\n          end: encodeLatLng(nextNode.getLatLng()),\n          edge: encodeLatLngs(nextEdge.getLatLngs()),\n          metadata: {\n            node: JSON.parse(JSON.stringify(nextNode.options.metadata)),\n            edge: JSON.parse(JSON.stringify(nextEdge.options.metadata)),\n          },\n        });\n\n        currentNode = nextNode;\n      } while (currentNode.options.type !== 'stopover');\n\n      if (group.length > 0) state.push(group);\n    });\n\n    return state;\n  },\n\n  _fireStart(payload = {}) {\n    if (this._fireEvents && this._computing === 0) this.fire('TrackDrawer:start', payload);\n    this._computing += 1;\n  },\n\n  _fireDone(payload = {}) {\n    this._computing -= 1;\n    // TODO: find a way to store states while computing\n    if (this._fireEvents && this._computing === 0) this._pushState();\n    if (this._fireEvents && this._computing === 0) this.fire('TrackDrawer:done', payload);\n  },\n\n  _fireFailed(error) {\n    this._computing -= 1;\n    if (this._fireEvents && this._computing === 0) this.fire('TrackDrawer:failed', { message: error.message });\n  },\n\n  async refreshEdges(routingCallback) {\n    const callback = routingCallback || this.options.routingCallback;\n\n    this._fireStart();\n    const oldValue = this._fireEvents;\n    this._fireEvents = false;\n\n    const promises = [];\n    this._nodesContainers.forEach((container) => {\n      const markers = container.getLayers();\n      markers.forEach((marker) => {\n        promises.push(this.onMoveNode(marker, callback));\n      });\n    });\n\n    await Promise.all(promises);\n\n    this._fireEvents = oldValue;\n    this._fireDone();\n    return this;\n  },\n\n  clean() {\n    this._fireStart();\n    this._edgesContainers.clean();\n    this._nodesContainers.clean();\n\n    this._firstNodeId = undefined;\n    this._lastNodeId = undefined;\n    this._currentColorIndex = 0;\n\n    this._fireDone();\n    return this;\n  },\n\n  _createNode(latlng, metadata = {}) {\n    return L.TrackDrawer.node(latlng, { metadata });\n  },\n\n  async restoreState(state, nodeCallback) {\n    const callback = nodeCallback || this._createNode;\n    this._fireStart();\n\n    const oldValue = this._fireEvents;\n    this._fireEvents = false;\n    this.clean();\n\n    const stopovers = [];\n    const routes = [];\n    const promises = [];\n\n    let version;\n\n    state.forEach((group, i) => {\n      if (i === 0) {\n        // eslint-disable-next-line prefer-destructuring\n        version = group.version;\n        if (group.start) {\n          const marker = callback.call(null, decodeLatLng(group.start), version >= 2 ? group.metadata : {});\n          promises.push(\n            this.addNode(\n              marker,\n              () => {\n                throw new Error('Should not be called');\n              },\n              true,\n            ),\n          );\n        }\n        return;\n      }\n\n      group.forEach((segment, j) => {\n        const marker = callback.call(null, decodeLatLng(segment.end), version >= 2 ? segment.metadata.node : {});\n        if (j === group.length - 1 && i < state.length - 1) {\n          stopovers.push(marker);\n        }\n\n        promises.push(\n          this.addNode(\n            marker,\n            (from, to, done) => {\n              const edge = decodeLatLngs(segment.edge);\n              routes.push({ from, to, edge });\n              done(null, edge, version >= 2 ? segment.metadata.edge : {});\n            },\n            true,\n          ),\n        );\n      });\n    });\n\n    await Promise.all(promises);\n\n    stopovers.forEach((m) => this.promoteNodeToStopover(m));\n\n    this._fireEvents = oldValue;\n    this._fireDone({ routes });\n    return this;\n  },\n\n  _pushState() {\n    if (this.options.undoable && !this._undoing) {\n      if (this._currentStateIndex + 1 !== this._states.length) {\n        this._states.splice(this._currentStateIndex + 1);\n      }\n      this._currentStateIndex += 1;\n      this._states.push(this.getState());\n\n      if (this._states.length - 1 > this.options.undoDepth) {\n        this._states.splice(0, 1);\n        this._currentStateIndex -= 1;\n      }\n    }\n  },\n\n  async undo(nodeCallback) {\n    if (this.isUndoable() && this._computing === 0) {\n      this._currentStateIndex -= 1;\n      this._undoing = true;\n      await this.restoreState(this._states[this._currentStateIndex], nodeCallback);\n      this._undoing = false;\n      return true;\n    }\n    return false;\n  },\n\n  isUndoable() {\n    return this.options.undoable && this._currentStateIndex > 0;\n  },\n\n  isRedoable() {\n    return this.options.undoable && this._currentStateIndex < this._states.length - 1;\n  },\n\n  async redo(nodeCallback) {\n    if (this.isRedoable() && this._computing === 0) {\n      this._currentStateIndex += 1;\n      this._undoing = true;\n      await this.restoreState(this._states[this._currentStateIndex], nodeCallback);\n      this._undoing = false;\n      return true;\n    }\n    return false;\n  },\n\n  addLayer(layer) {\n    if (layer instanceof L.Marker) {\n      this.addNode(layer);\n    } else {\n      L.LayerGroup.prototype.addLayer.call(this, layer);\n    }\n  },\n\n  _createEdge(previousNode, node, metadata = {}) {\n    const edgesContainer = this._edgesContainers.get(this._getNodeContainerIndex(previousNode));\n    const edge = new Edge([previousNode.getLatLng(), node.getLatLng()], {\n      color: Colors.nameToRgb(previousNode.options.colorName),\n      dashArray: '4',\n      metadata,\n    }).addTo(edgesContainer);\n    const id = edgesContainer.getLayerId(edge);\n\n    previousNode._routeIdNext = id;\n    node._routeIdPrevious = id;\n    edge._startMarkerId = this._getNodeId(previousNode);\n    edge._endMarkerId = this._getNodeId(node);\n    edge._computation = 0;\n\n    if (this.options.debug) {\n      edge.on('tooltipopen', () => {\n        const startNodeId = edge._startMarkerId;\n        const endNodeId = edge._endMarkerId;\n\n        edge.setTooltipContent(\n          `id: ${this._getEdgeId(edge)} (on #${this._getEdgeContainerIndex(edge)})<br>`\n          + `previous node: ${startNodeId}`\n          + ` (on #${this._getNodeContainerIndex(this._getNode(startNodeId))})<br>`\n          + `next node: ${endNodeId}`\n          + ` (on #${this._getNodeContainerIndex(this._getNode(endNodeId))})`,\n        );\n      });\n      edge.bindTooltip('<>');\n    }\n\n    return edge;\n  },\n\n  _prepareNode(node, nodesContainer) {\n    if (this.options.debug) {\n      node.on('tooltipopen', () => {\n        const { previousEdge, previousNode } = this._getPrevious(node);\n        const { nextEdge, nextNode } = this._getNext(node);\n\n        node.setTooltipContent(\n          `id: ${this._getNodeId(node)} (on #${this._getNodeContainerIndex(node)})<br>`\n          + `previous edge: ${this._getEdgeId(previousEdge)}`\n          + ` (on #${this._getEdgeContainerIndex(previousEdge)}) to ${this._getNodeId(previousNode)}<br>`\n          + `next edge: ${this._getEdgeId(nextEdge)}`\n          + ` (on #${this._getEdgeContainerIndex(nextEdge)}) to ${this._getNodeId(nextNode)}`,\n        );\n      });\n      node.bindTooltip('<>');\n    }\n\n    if (nodesContainer.getLayers().length > 0) {\n      const previousNode = nodesContainer.getLayers()[0];\n      node.setStyle({ colorName: previousNode.options.colorName });\n    } else {\n      node.setStyle({ colorName: Colors.nameOf(this._currentColorIndex) });\n    }\n\n    if (node.options.draggable) {\n      node.on('dragstart', (e) => this._onDragStartNode(e.target));\n      node.on('drag', (e) => this._onDragNode(e.target));\n      node.on('moveend', (e) => this.onMoveNode(e.target));\n    }\n\n    node.addTo(nodesContainer);\n\n    return this;\n  },\n\n  addNode(node, routingCallback, skipChecks = false) {\n    const callback = routingCallback || this.options.routingCallback;\n\n    if (this._lastNodeId !== undefined && !skipChecks) {\n      const previousNode = this._getNode(this._lastNodeId);\n      if (previousNode.getLatLng().equals(node.getLatLng())) {\n        return new Promise((resolve) => {\n          resolve();\n        });\n      }\n    }\n\n    this._fireStart();\n\n    const nodesContainer = this._nodesContainers.get(-1);\n    this._prepareNode(node, nodesContainer);\n\n    if (this._lastNodeId !== undefined) {\n      const previousNode = this._getNode(this._lastNodeId);\n      this._createEdge(previousNode, node);\n    }\n\n    const lastNodeId = this._lastNodeId;\n    this._lastNodeId = this._getNodeId(node);\n    if (this._firstNodeId === undefined) {\n      this._firstNodeId = this._lastNodeId;\n    }\n\n    const oldValue = this._fireEvents;\n    this._fireEvents = false;\n    if (node.options.type === 'stopover') {\n      this.promoteNodeToStopover(node);\n    }\n    this._fireEvents = oldValue;\n\n    if (lastNodeId === undefined) {\n      return new Promise((resolve) => {\n        resolve();\n      }).then(() => {\n        this._fireDone({});\n      });\n    }\n\n    const { previousEdge, previousNode } = this._getPrevious(node);\n    previousEdge._computation += 1;\n    const currentComputation = previousEdge._computation;\n\n    return new Promise((resolve, reject) => {\n      callback.call(null, previousNode, node, (err, route, metadata = {}) => {\n        if (err !== null) {\n          reject(err);\n          return;\n        }\n\n        if (previousEdge._computation === currentComputation) {\n          // Route can give different precision than initial markers\n          // Use precision given by the route to be consistent\n          previousNode.setLatLng(L.latLng(route[0]));\n          node.setLatLng(L.latLng(route[route.length - 1]));\n          previousEdge.setLatLngs(route);\n          previousEdge.options.metadata = JSON.parse(JSON.stringify(metadata));\n          previousEdge.setStyle({ dashArray: null });\n        }\n\n        resolve({ routes: [{ from: previousNode, to: node, previousEdge }] });\n      });\n    })\n      .then((routes) => {\n        this._fireDone({ routes });\n      })\n      .catch((e) => {\n        this._fireFailed(e);\n      });\n  },\n\n  insertNode(node, route, routingCallback) {\n    const callback = routingCallback || this.options.routingCallback;\n\n    const startMarker = this._getNode(route._startMarkerId);\n    const endMarker = this._getNode(route._endMarkerId);\n\n    route.removeFrom(this._getEdgeContainer(route));\n    this._prepareNode(node, this._getNodeContainer(startMarker));\n\n    const edge1 = this._createEdge(startMarker, node);\n    const edge2 = this._createEdge(node, endMarker);\n\n    this._fireStart();\n\n    edge1._computation += 1;\n    edge2._computation += 1;\n    const currentComputation1 = edge1._computation;\n    const currentComputation2 = edge2._computation;\n\n    const promise1 = new Promise((resolve, reject) => {\n      callback.call(null, startMarker, node, (err, route1, metadata1 = {}) => {\n        if (err !== null) {\n          reject(err);\n          return;\n        }\n\n        if (edge1._computation === currentComputation1) {\n          startMarker.setLatLng(L.latLng(route1[0]));\n          node.setLatLng(L.latLng(route1[route1.length - 1]));\n          edge1.setLatLngs(route1);\n          edge1.options.metadata = JSON.parse(JSON.stringify(metadata1));\n          edge1.setStyle({ dashArray: null });\n        }\n        resolve({ from: startMarker, to: node, edge: edge1 });\n      });\n    });\n\n    const promise2 = new Promise((resolve, reject) => {\n      callback.call(null, node, endMarker, (err, route2, metadata2 = {}) => {\n        if (err !== null) {\n          reject(err);\n          return;\n        }\n\n        if (edge2._computation === currentComputation2) {\n          node.setLatLng(L.latLng(route2[0]));\n          endMarker.setLatLng(L.latLng(route2[route2.length - 1]));\n          edge2.setLatLngs(route2);\n          edge2.options.metadata = JSON.parse(JSON.stringify(metadata2));\n          edge2.setStyle({ dashArray: null });\n        }\n        resolve({ from: node, to: endMarker, edge: edge2 });\n      });\n    });\n\n    return Promise.all([promise1, promise2])\n      .then((routes) => {\n        this._fireDone({ routes });\n      })\n      .catch((e) => {\n        this._fireFailed(e);\n      });\n  },\n\n  _onDragStartNode(marker) {\n    const { previousEdge } = this._getPrevious(marker);\n    const { nextEdge } = this._getNext(marker);\n    if (previousEdge !== undefined) {\n      previousEdge.setStyle({ dashArray: '4' });\n    }\n    if (nextEdge !== undefined) {\n      nextEdge.setStyle({ dashArray: '4' });\n    }\n    return this;\n  },\n\n  _onDragNode(marker) {\n    const { previousEdge, previousNode } = this._getPrevious(marker);\n    const { nextEdge, nextNode } = this._getNext(marker);\n    if (previousEdge !== undefined) {\n      previousEdge.setLatLngs([previousNode.getLatLng(), marker.getLatLng()]);\n    }\n    if (nextEdge !== undefined) {\n      nextEdge.setLatLngs([nextNode.getLatLng(), marker.getLatLng()]);\n    }\n    return this;\n  },\n\n  onMoveNode(marker, routingCallback) {\n    const callback = routingCallback || this.options.routingCallback;\n\n    const promises = [];\n    const { previousEdge, previousNode } = this._getPrevious(marker);\n    const { nextEdge, nextNode } = this._getNext(marker);\n\n    this._fireStart();\n    this._onDragStartNode(marker);\n    this._onDragNode(marker);\n\n    if (previousEdge !== undefined) {\n      previousEdge._computation += 1;\n      const currentComputation = previousEdge._computation;\n\n      promises.push(\n        new Promise((resolve, reject) => {\n          callback.call(null, previousNode, marker, (err, route, metadata = {}) => {\n            if (err !== null) {\n              reject(err);\n              return;\n            }\n\n            if (previousEdge._computation === currentComputation) {\n              marker.setLatLng(L.latLng(route[route.length - 1]));\n              previousEdge.setLatLngs(route);\n              previousEdge.options.metadata = JSON.parse(JSON.stringify(metadata));\n              previousEdge.setStyle({ dashArray: null });\n            }\n\n            resolve({ from: previousNode, to: marker, edge: previousEdge });\n          });\n        }),\n      );\n    }\n\n    if (nextEdge !== undefined) {\n      nextEdge._computation += 1;\n      const currentComputation = nextEdge._computation;\n\n      promises.push(\n        new Promise((resolve, reject) => {\n          callback.call(null, marker, nextNode, (err, route, metadata = {}) => {\n            if (err !== null) {\n              reject(err);\n              return;\n            }\n\n            if (nextEdge._computation === currentComputation) {\n              marker.setLatLng(L.latLng(route[0]));\n              nextEdge.setLatLngs(route);\n              nextEdge.options.metadata = JSON.parse(JSON.stringify(metadata));\n              nextEdge.setStyle({ dashArray: null });\n            }\n\n            resolve({ from: marker, to: nextNode, edge: nextEdge });\n          });\n        }),\n      );\n    }\n\n    return Promise.all(promises)\n      .then((routes) => {\n        this._fireDone({ routes });\n      })\n      .catch((e) => {\n        this._fireFailed(e);\n      });\n  },\n\n  removeNode(node, routingCallback) {\n    const callback = routingCallback || this.options.routingCallback;\n\n    const promises = [];\n\n    this._fireStart();\n\n    const oldValue = this._fireEvents;\n    this._fireEvents = false;\n    this.demoteNodeToWaypoint(node);\n    this._fireEvents = oldValue;\n\n    const nodeContainer = this._getNodeContainer(node);\n\n    const { previousEdge, previousNode } = this._getPrevious(node);\n    const { nextEdge, nextNode } = this._getNext(node);\n\n    if (previousEdge !== undefined && nextEdge !== undefined) {\n      // Intermediate marker\n      nextNode._routeIdPrevious = node._routeIdPrevious;\n      previousEdge._endMarkerId = nextEdge._endMarkerId;\n\n      nextEdge.removeFrom(this._getEdgeContainer(nextEdge));\n      node.removeFrom(nodeContainer);\n      previousEdge.setLatLngs([previousNode.getLatLng(), nextNode.getLatLng()]).setStyle({ dashArray: '4' });\n\n      previousEdge._computation += 1;\n      const currentComputation = previousEdge._computation;\n\n      promises.push(\n        new Promise((resolve, reject) => {\n          callback.call(null, previousNode, nextNode, (err, route, metadata = {}) => {\n            if (err !== null) {\n              reject(err);\n              return;\n            }\n\n            if (previousEdge._computation === currentComputation) {\n              previousEdge.setLatLngs(route).setStyle({ dashArray: null });\n              previousEdge.options.metadata = JSON.parse(JSON.stringify(metadata));\n            }\n\n            resolve({ from: previousNode, to: nextNode, edge: previousEdge });\n          });\n        }),\n      );\n    } else if (previousEdge !== undefined) {\n      // Last marker of path\n      previousNode._routeIdNext = undefined;\n      this._lastNodeId = previousEdge._startMarkerId;\n      previousEdge.removeFrom(this._getEdgeContainer(previousEdge));\n      node.removeFrom(nodeContainer);\n    } else if (nextEdge !== undefined) {\n      // First marker of path\n      nextNode._routeIdPrevious = undefined;\n      this._firstNodeId = nextEdge._endMarkerId;\n      nextEdge.removeFrom(this._getEdgeContainer(nextEdge));\n      node.removeFrom(nodeContainer);\n    } else {\n      // Lonely marker\n      this._lastNodeId = undefined;\n      this._firstNodeId = undefined;\n      node.removeFrom(nodeContainer);\n    }\n\n    return Promise.all(promises)\n      .then((routes) => {\n        this._fireDone({ routes });\n      })\n      .catch((e) => {\n        this._fireFailed(e);\n      });\n  },\n\n  promoteNodeToStopover(node) {\n    if (node._promoted) {\n      return this;\n    }\n\n    if (this._getNodeId(node) === this._firstNodeId) {\n      node.setType('stopover');\n      node._promoted = true;\n      node._demoted = false;\n      return this;\n    }\n\n    this._fireStart();\n\n    const index = this._getNodeContainerIndex(node);\n\n    const nodes = [];\n    const edges = [];\n\n    let currentNode = node;\n    do {\n      nodes.push(currentNode);\n      const { nextEdge, nextNode } = this._getNext(currentNode);\n      if (nextEdge === undefined) {\n        break;\n      }\n\n      nodes.push(currentNode);\n      edges.push(nextEdge);\n\n      currentNode = nextNode;\n    } while (currentNode.options.type !== 'stopover');\n\n    const newNodesContainer = L.featureGroup();\n    const newEdgesContainer = L.featureGroup();\n\n    this._nodesContainers.splice(index + 1, 0, newNodesContainer);\n    this._edgesContainers.splice(index + 1, 0, newEdgesContainer);\n    this._currentColorIndex += 1;\n\n    nodes.forEach((e) => {\n      e.removeFrom(this._getNodeContainer(e)).addTo(newNodesContainer);\n    });\n    edges.forEach((e) => {\n      e.removeFrom(this._getEdgeContainer(e)).addTo(newEdgesContainer);\n    });\n\n    newNodesContainer.setStyle({ colorName: Colors.nameOf(this._currentColorIndex) });\n    newEdgesContainer.setStyle({ color: Colors.rgbOf(this._currentColorIndex) });\n\n    node.setType('stopover');\n    node._promoted = true;\n    node._demoted = false;\n\n    this._fireDone();\n    return this;\n  },\n\n  demoteNodeToWaypoint(node) {\n    if (node._demoted) {\n      return this;\n    }\n\n    const index = this._getNodeContainerIndex(node);\n    if (index === 0) {\n      return this;\n    }\n\n    this._fireStart();\n\n    const nodes = [];\n    const edges = [];\n\n    let currentNode = node;\n    do {\n      nodes.push(currentNode);\n      const { nextEdge, nextNode } = this._getNext(currentNode);\n      if (nextEdge === undefined) {\n        break;\n      }\n\n      nodes.push(currentNode);\n      edges.push(nextEdge);\n\n      currentNode = nextNode;\n    } while (currentNode.options.type !== 'stopover');\n\n    const previousNodesContainer = this._nodesContainers.get(index - 1);\n    const previousEdgesContainer = this._edgesContainers.get(index - 1);\n\n    this._nodesContainers.splice(index, 1);\n    this._edgesContainers.splice(index, 1);\n\n    nodes.forEach((e) => {\n      e.removeFrom(this._getNodeContainer(e)).addTo(previousNodesContainer);\n    });\n    edges.forEach((e) => {\n      e.removeFrom(this._getEdgeContainer(e)).addTo(previousEdgesContainer);\n    });\n\n    const { previousEdge, previousNode } = this._getPrevious(nodes[0]);\n    if (previousEdge !== undefined) {\n      previousNodesContainer.setStyle({ colorName: previousNode.options.colorName });\n      previousEdgesContainer.setStyle({ color: previousEdge.options.color });\n    }\n\n    node.setType('waypoint');\n    node._promoted = false;\n    node._demoted = true;\n\n    this._fireDone();\n    return this;\n  },\n});\n\nmodule.exports = {\n  Track,\n  track(options) {\n    return new Track(options);\n  },\n};\n","const L = require('leaflet');\n\nif (L.Control.EasyBar === undefined) {\n  module.exports = {\n    ToolBar: undefined,\n    toolBar: undefined,\n  };\n} else {\n  const ToolBar = L.Control.EasyBar.extend({\n    options: {\n      mode: null,\n      labelAddMarker: 'Add marker on click',\n      labelInsertMarker: 'Insert marker when clicking on track',\n      labelCloseLoop: 'Close the loop',\n      labelDeleteMarker: 'Delete marker on click',\n      labelPromoteMarker: 'Promote to stopover on click',\n      labelDemoteMarker: 'Demote to waypoint on click',\n      labelClean: 'Remove everything now',\n      labelUndo: 'Undo',\n      labelRedo: 'Redo',\n    },\n\n    initialize(track, options) {\n      this._track = track;\n\n      L.Util.setOptions(this, options);\n      L.Control.EasyBar.prototype.initialize.call(this, this._initializeButtons(), options);\n      this.setMode(this.options.mode);\n\n      this._track.getStepsContainer().on('click', (e) => {\n        if (this.options.mode === 'insert') {\n          const marker = L.TrackDrawer.node(e.latlng);\n          const route = e.layer;\n\n          route.setStyle({ weight: 3 });\n          this._track.insertNode(marker, route);\n          this._bindMarkerEvents(marker);\n        }\n      });\n\n      this._track.getStepsContainer().on('mouseover', (e) => {\n        if (this.options.mode === 'insert') {\n          e.layer.setStyle({ weight: 5 });\n        }\n      });\n\n      this._track.getStepsContainer().on('mouseout', (e) => {\n        if (this.options.mode === 'insert') {\n          e.layer.setStyle({ weight: 3 });\n        }\n      });\n\n      this._track._toolbar = this;\n      this._track._bindMarkerEvents = (marker) => {\n        this._bindMarkerEvents(marker);\n      };\n    },\n\n    setMode(m) {\n      this.options.mode = m;\n      this._addBtn.state('loaded');\n      this._insertBtn.state('loaded');\n      this._deleteBtn.state('loaded');\n      this._promoteBtn.state('loaded');\n      this._demoteBtn.state('loaded');\n\n      if (this._map) {\n        this._map.getContainer().style.cursor = '';\n      }\n\n      switch (this.options.mode) {\n        case 'add': {\n          this._addBtn.state('active');\n          if (this._map) {\n            this._map.getContainer().style.cursor = 'pointer';\n          }\n          break;\n        }\n        case 'insert': {\n          this._insertBtn.state('active');\n          break;\n        }\n        case 'delete': {\n          this._deleteBtn.state('active');\n          break;\n        }\n        case 'promote': {\n          this._promoteBtn.state('active');\n          break;\n        }\n        case 'demote': {\n          this._demoteBtn.state('active');\n          break;\n        }\n        default:\n        // Do nothing\n      }\n\n      return this;\n    },\n\n    _initializeButtons() {\n      const buttons = [];\n      this._addBtn = L.easyButton({\n        id: 'trackdrawer-add',\n        states: [\n          {\n            stateName: 'loaded',\n            icon: 'fa-plus',\n            title: this.options.labelAddMarker,\n            onClick: () => {\n              this.setMode('add');\n            },\n          },\n          {\n            stateName: 'active',\n            icon: 'fa-plus',\n            title: this.options.labelAddMarker,\n            onClick: () => {\n              this.setMode(null);\n            },\n          },\n        ],\n      });\n      buttons.push(this._addBtn);\n      this._insertBtn = L.easyButton({\n        id: 'trackdrawer-insert',\n        states: [\n          {\n            stateName: 'loaded',\n            icon: 'fa-plus-circle',\n            title: this.options.labelInsertMarker,\n            onClick: () => {\n              this.setMode('insert');\n            },\n          },\n          {\n            stateName: 'active',\n            icon: 'fa-plus-circle',\n            title: this.options.labelInsertMarker,\n            onClick: () => {\n              this.setMode(null);\n            },\n          },\n        ],\n      });\n      buttons.push(this._insertBtn);\n      this._closeLoop = L.easyButton({\n        id: 'trackdrawer-closeloop',\n        states: [\n          {\n            stateName: 'loaded',\n            icon: 'fa-magic',\n            title: this.options.labelCloseLoop,\n            onClick: () => {\n              if (this._track.hasNodes(2)) {\n                const nodes = this._track.getNodes();\n                const marker = L.TrackDrawer.node(nodes[0].markers[0].getLatLng()).addTo(this._track);\n                this._bindMarkerEvents(marker);\n              }\n            },\n          },\n        ],\n      });\n      buttons.push(this._closeLoop);\n      this._deleteBtn = L.easyButton({\n        id: 'trackdrawer-delete',\n        states: [\n          {\n            stateName: 'loaded',\n            icon: 'fa-eraser',\n            title: this.options.labelDeleteMarker,\n            onClick: () => {\n              this.setMode('delete');\n            },\n          },\n          {\n            stateName: 'active',\n            icon: 'fa-eraser',\n            title: this.options.labelDeleteMarker,\n            onClick: () => {\n              this.setMode(null);\n            },\n          },\n        ],\n      });\n      buttons.push(this._deleteBtn);\n      this._promoteBtn = L.easyButton({\n        id: 'trackdrawer-promote',\n        states: [\n          {\n            stateName: 'loaded',\n            icon: 'fa-pause-circle',\n            title: this.options.labelPromoteMarker,\n            onClick: () => {\n              this.setMode('promote');\n            },\n          },\n          {\n            stateName: 'active',\n            icon: 'fa-pause-circle',\n            title: this.options.labelPromoteMarker,\n            onClick: () => {\n              this.setMode(null);\n            },\n          },\n        ],\n      });\n      buttons.push(this._promoteBtn);\n      this._demoteBtn = L.easyButton({\n        id: 'trackdrawer-demote',\n        states: [\n          {\n            stateName: 'loaded',\n            icon: 'fa-map-signs',\n            title: this.options.labelDemoteMarker,\n            onClick: () => {\n              this.setMode('demote');\n            },\n          },\n          {\n            stateName: 'active',\n            icon: 'fa-map-signs',\n            title: this.options.labelDemoteMarker,\n            onClick: () => {\n              this.setMode(null);\n            },\n          },\n        ],\n      });\n      buttons.push(this._demoteBtn);\n      this._cleanBtn = L.easyButton({\n        id: 'trackdrawer-clean',\n        states: [\n          {\n            icon: 'fa-trash',\n            title: this.options.labelClean,\n            onClick: () => {\n              this._track.clean();\n            },\n          },\n        ],\n      });\n      buttons.push(this._cleanBtn);\n\n      if (this._track.options.undoable) {\n        this._undoBtn = L.easyButton({\n          id: 'trackdrawer-undo',\n          states: [\n            {\n              icon: 'fa-undo',\n              title: this.options.labelUndo,\n              onClick: () => {\n                this._track.undo((latlng) => {\n                  const marker = L.TrackDrawer.node(latlng);\n                  this._bindMarkerEvents(marker);\n                  return marker;\n                });\n              },\n            },\n          ],\n        });\n        buttons.push(this._undoBtn);\n        this._redoBtn = L.easyButton({\n          id: 'trackdrawer-redo',\n          states: [\n            {\n              icon: 'fa-repeat',\n              title: this.options.labelRedo,\n              onClick: () => {\n                this._track.redo((latlng) => {\n                  const marker = L.TrackDrawer.node(latlng);\n                  this._bindMarkerEvents(marker);\n                  return marker;\n                });\n              },\n            },\n          ],\n        });\n        buttons.push(this._redoBtn);\n      }\n\n      this._track.on('TrackDrawer:start', () => {\n        if (this._track.options.undoable) {\n          this._undoBtn.disable();\n          this._redoBtn.disable();\n        }\n      });\n\n      this._track.on('TrackDrawer:done', () => {\n        if (this._track.hasNodes(2)) {\n          this._closeLoop.enable();\n        } else {\n          this._closeLoop.disable();\n        }\n\n        if (this._track.hasNodes()) {\n          this._insertBtn.enable();\n          this._deleteBtn.enable();\n          this._promoteBtn.enable();\n          this._demoteBtn.enable();\n          this._cleanBtn.enable();\n        } else {\n          this._insertBtn.disable();\n          this._deleteBtn.disable();\n          this._promoteBtn.disable();\n          this._demoteBtn.disable();\n          this._cleanBtn.disable();\n        }\n\n        if (this._track.options.undoable) {\n          if (this._track.isUndoable()) {\n            this._undoBtn.enable();\n          } else {\n            this._undoBtn.disable();\n          }\n          if (this._track.isRedoable()) {\n            this._redoBtn.enable();\n          } else {\n            this._redoBtn.disable();\n          }\n        }\n      });\n\n      return buttons;\n    },\n\n    _bindMarkerEvents(marker) {\n      marker.on('click', this._onMarkerClickHandler);\n      marker.on('mouseover', this._onMarkerMouseOverHandler);\n      marker.on('mouseout', this._onMarkerMouseOutHandler);\n      return this;\n    },\n\n    onAdd(map) {\n      this._onMapClickHandler = (e) => {\n        if (this.options.mode === 'add') {\n          const marker = L.TrackDrawer.node(e.latlng).addTo(this._track);\n          this._bindMarkerEvents(marker);\n        }\n      };\n\n      this._onMarkerClickHandler = (e) => {\n        const marker = e.target;\n        switch (this.options.mode) {\n          case 'delete': {\n            const { previousEdge } = this._track._getPrevious(marker);\n            const { nextEdge } = this._track._getNext(marker);\n\n            if (previousEdge) previousEdge.setStyle({ weight: 3 });\n            if (nextEdge) nextEdge.setStyle({ weight: 3 });\n\n            this._track.removeNode(marker);\n            break;\n          }\n          case 'promote': {\n            this._track.promoteNodeToStopover(marker);\n            break;\n          }\n          case 'demote': {\n            this._track.demoteNodeToWaypoint(marker);\n            break;\n          }\n          default:\n        }\n      };\n\n      this._onMarkerMouseOverHandler = (e) => {\n        if (this.options.mode === 'delete' || this.options.mode === 'promote' || this.options.mode === 'demote') {\n          const marker = e.target;\n          const { previousEdge } = this._track._getPrevious(marker);\n          const { nextEdge } = this._track._getNext(marker);\n\n          if (previousEdge) previousEdge.setStyle({ weight: 5 });\n          if (nextEdge) nextEdge.setStyle({ weight: 5 });\n        }\n      };\n\n      this._onMarkerMouseOutHandler = (e) => {\n        const marker = e.target;\n        const { previousEdge } = this._track._getPrevious(marker);\n        const { nextEdge } = this._track._getNext(marker);\n\n        if (previousEdge) previousEdge.setStyle({ weight: 3 });\n        if (nextEdge) nextEdge.setStyle({ weight: 3 });\n      };\n\n      L.DomEvent.on(map, 'click', this._onMapClickHandler);\n      return L.Control.EasyBar.prototype.onAdd.call(this, map);\n    },\n\n    onRemove(map) {\n      if (this.options.mode === 'add') map.getContainer().style.cursor = '';\n\n      L.DomEvent.off(map, 'click', this._onMapClickHandler);\n      this._track.getNodes().forEach((nodes) => {\n        nodes.markers.forEach((marker) => {\n          marker.off('click', this._onMarkerClickHandler);\n          marker.off('mouseover', this._onMarkerMouseOverHandler);\n          marker.off('mouseout', this._onMarkerMouseOutHandler);\n        });\n      });\n    },\n  });\n\n  module.exports = {\n    ToolBar,\n    toolBar(track, options) {\n      return new ToolBar(track, options);\n    },\n  };\n}\n","const L = require('leaflet');\n\nif (L.Control.EasyBar === undefined) {\n  module.exports = {\n    TraceModeBar: undefined,\n    traceModeBar: undefined,\n  };\n} else {\n  const TraceModeBar = L.Control.EasyBar.extend({\n    options: {\n      mode: null,\n    },\n\n    initialize(track, modes, options) {\n      this._track = track;\n      this._buttonsMap = {};\n\n      L.Control.EasyBar.prototype.initialize.call(this, this._initializeButtons(modes), options);\n      this.setMode(this.options.mode);\n    },\n\n    setMode(m) {\n      const ids = Object.keys(this._buttonsMap);\n      let newMode = m;\n      if (newMode === null) {\n        const idx = this.options.mode === ids[0] ? 1 : 0;\n        newMode = ids[idx];\n      }\n\n      this.options.mode = newMode;\n      ids.forEach((key) => {\n        this._buttonsMap[key].btn.state('loaded');\n      });\n\n      this._buttonsMap[newMode].btn.state('active');\n      this._track.setOptions({\n        router: this._buttonsMap[newMode].router,\n        routingCallback: this._buttonsMap[newMode].routingCallback,\n      });\n\n      return this;\n    },\n\n    _initializeButtons(modes) {\n      const buttons = [];\n      modes.forEach((m) => {\n        const btn = L.easyButton({\n          id: `trackdrawer-mode-${m.id}`,\n          states: [\n            {\n              stateName: 'loaded',\n              icon: m.icon,\n              title: m.name,\n              onClick: () => {\n                this.setMode(m.id);\n              },\n            },\n            {\n              stateName: 'active',\n              icon: m.icon,\n              title: m.name,\n              onClick: () => {\n                this.setMode(null);\n              },\n            },\n          ],\n        });\n        buttons.push(btn);\n        this._buttonsMap[m.id] = {\n          router: m.router,\n          routingCallback: m.routingCallback,\n          btn,\n        };\n      });\n\n      return buttons;\n    },\n  });\n\n  module.exports = {\n    TraceModeBar,\n    traceModeBar(track, modes, options) {\n      return new TraceModeBar(track, modes, options);\n    },\n  };\n}\n","const L = require('leaflet');\n\nconst Node = L.Marker.extend({\n  _routeIdPrevious: undefined,\n  _routeIdNext: undefined,\n  _promoted: false,\n  _demoted: true,\n\n  options: {\n    type: 'waypoint', // Or 'stopover',\n    colorName: 'blue',\n    opacity: 1,\n    draggable: true,\n    metadata: {},\n  },\n\n  initialize(latlng, options) {\n    L.Marker.prototype.initialize.call(this, latlng, options);\n    L.setOptions(this, options);\n    this.setType(this.options.type);\n    this.options.metadata = JSON.parse(JSON.stringify(this.options.metadata));\n  },\n\n  setType(type) {\n    this.options.type = type;\n\n    if (type === 'stopover') {\n      this.setIcon(\n        L.AwesomeMarkers.icon({\n          icon: 'pause-circle',\n          markerColor: this.options.colorName,\n          prefix: 'fa',\n        }),\n      );\n    } else {\n      this.setIcon(\n        L.AwesomeMarkers.icon({\n          icon: 'map-signs',\n          markerColor: this.options.colorName,\n          prefix: 'fa',\n        }),\n      );\n    }\n    return this;\n  },\n\n  setStyle(style) {\n    L.Util.setOptions(this, style);\n\n    if ('colorName' in style) {\n      // Colors is set only via the icon and there's no setter on L.AwesomeMarkers\n      this.setType(this.options.type);\n    }\n    if ('opacity' in style) {\n      this.setOpacity(this.options.opacity);\n    }\n\n    return this;\n  },\n});\n\nmodule.exports = {\n  Node,\n  node(latlng, options) {\n    return new Node(latlng, options);\n  },\n};\n","const L = require('leaflet');\n\n/**\n * Splits an array of LatLng objects every X meters\n * @param {L.LatLng[]} latlngs Polyline to split\n * @param {int} distance Max. distance of each segment of the polyline (in meters)\n * @returns L.LatLng[][]\n */\nfunction splitLatLngs(latlngs, distance = 100) {\n  if (distance <= 0) throw new Error('`distance` must be positive');\n  if (latlngs.length === 0) return [[]];\n\n  let result = [];\n  if (Array.isArray(latlngs[0])) {\n    for (let j = 0; j < latlngs.length; j += 1) {\n      result = result.concat(splitLatLngs(latlngs[j], distance));\n    }\n\n    return result;\n  }\n\n  let tmp = latlngs.splice(0, 1);\n  while (latlngs.length > 0) {\n    const latlng = L.latLng(latlngs.splice(0, 1)[0]);\n    tmp.push(latlng);\n    if (latlng.distanceTo(tmp[0]) > distance) {\n      result.push(tmp);\n      tmp = [latlng];\n    }\n  }\n  result.push(tmp);\n\n  return result;\n}\n\n/**\n * Splits a L.Polyline object every X meters\n * @param {L.Polyline} polyline Polyline to split\n * @param {int} distance Max. distance of each segment of the polyline (in meters)\n * @returns L.Polyline[]\n */\nfunction splitPolyline(polyline, distance = 100) {\n  return splitLatLngs(polyline.getLatLngs(), distance).map((a) => L.polyline(a));\n}\n\nfunction featureGroupToPolylines(featureGroup) {\n  return featureGroup.getLayers().filter((layer) => layer instanceof L.Polyline);\n}\n\nfunction featureGroupToLatLngs(featureGroup) {\n  return featureGroupToPolylines(featureGroup).map((layer) => [layer.getLatLngs(), layer.feature.properties]);\n}\n\nmodule.exports = {\n  splitPolyline,\n  splitLatLngs,\n  featureGroupToPolylines,\n  featureGroupToLatLngs,\n};\n","/* eslint-disable arrow-parens */\nconst L = require('leaflet');\nconst corslite = require('@mapbox/corslite');\nconst { Track } = require('./Track');\nconst latlngutils = require('./LatLngUtils');\n\nTrack.include({\n  _createFileLoader() {\n    this._fileLoader = L.FileLayer.fileLoader(null, {\n      addToMap: false,\n      fileSizeLimit: this.options.fileSizeLimit || 1024,\n      formats: this.options.fileFormat || ['.geojson', '.json', '.kml', '.gpx'],\n    });\n  },\n\n  createFileLoaderControl(insertWaypoints = false) {\n    this._fileLoaderController = L.Control.fileLayerLoad({\n      addToMap: false,\n      fileSizeLimit: this.options.fileSizeLimit || 1024,\n      formats: this.options.fileFormat || ['.geojson', '.json', '.kml', '.gpx'],\n    }).addTo(this._map);\n\n    this._fileLoaderController.loader.on('data:loaded', (event) => {\n      this._dataLoadedHandler(event.layer, insertWaypoints);\n    });\n\n    return this._fileLoaderController;\n  },\n\n  async _dataLoadedHandler(layer, insertWaypoints = false) {\n    this._fireStart();\n\n    const oldValue = this._fireEvents;\n    this._fireEvents = false;\n    this.clean();\n\n    const latlngs = insertWaypoints\n      ? latlngutils.featureGroupToLatLngs(layer).map(l => [latlngutils.splitLatLngs(l[0]), l[1]])\n      : latlngutils.featureGroupToLatLngs(layer).map(l => [[l[0]], l[1]]);\n\n    let lastMarker;\n    const hasToolbar = this._toolbar !== undefined;\n    /* eslint-disable no-await-in-loop */\n    for (let i = 0; i < latlngs.length; i += 1) {\n      const properties = latlngs[i][1];\n      for (let j = 0; j < latlngs[i][0].length; j += 1) {\n        const l = latlngs[i][0][j];\n        if (l.length > 0) {\n          if (lastMarker === undefined) {\n            lastMarker = L.TrackDrawer.node(l[0]);\n            await this.addNode(lastMarker, undefined, true);\n            if (hasToolbar) this._bindMarkerEvents(lastMarker);\n          }\n\n          lastMarker = L.TrackDrawer.node(l[l.length - 1], {\n            type: j === latlngs[i][0].length - 1 ? 'stopover' : 'waypoint',\n          });\n          await this.addNode(\n            lastMarker,\n            (_n1, _n2, cb) => {\n              cb(null, l, properties);\n            },\n            true,\n          );\n          if (hasToolbar) this._bindMarkerEvents(lastMarker);\n        }\n      }\n    }\n    /* eslint-enable no-await-in-loop */\n\n    this._fireEvents = oldValue;\n    this._fireDone();\n  },\n\n  loadData(data, name, ext, insertWaypoints = false) {\n    return new Promise((resolve, reject) => {\n      this._fileLoader.on('data:loaded', async (event) => {\n        await this._dataLoadedHandler(event.layer, insertWaypoints);\n        this._fileLoader.off();\n        resolve();\n      });\n      this._fileLoader.on('data:error', (error) => {\n        this._fileLoader.off();\n        reject(error.error);\n      });\n\n      this._fileLoader.loadData(data, name, ext);\n    });\n  },\n\n  loadFile(file, insertWaypoints = false) {\n    return new Promise((resolve, reject) => {\n      this._fileLoader.on('data:loaded', async (event) => {\n        await this._dataLoadedHandler(event.layer, insertWaypoints);\n        this._fileLoader.off();\n        resolve();\n      });\n      this._fileLoader.on('data:error', (error) => {\n        this._fileLoader.off();\n        reject(error.error);\n      });\n\n      this._fileLoader.load(file);\n    });\n  },\n\n  loadUrl(url, useProxy = false, insertWaypoints = false) {\n    const filename = url.split('/').pop();\n    const ext = filename.split('.').pop();\n\n    const proxiedUrl = useProxy ? `fetch.php?url=${encodeURI(url)}` : url;\n\n    return new Promise((resolve, reject) => {\n      corslite(\n        proxiedUrl,\n        (err, resp) => {\n          if (!err) {\n            try {\n              this._fileLoader.on('data:loaded', async (event) => {\n                await this._dataLoadedHandler(event.layer, insertWaypoints);\n                this._fileLoader.off();\n                resolve();\n              });\n              this._fileLoader.on('data:error', (error) => {\n                this._fileLoader.off();\n                reject(error.error);\n              });\n              this._fileLoader.loadData(resp.responseText, filename, ext);\n            } catch (ex) {\n              reject(ex);\n            }\n          } else if (err.responseText) {\n            try {\n              // Check if response is JSON\n              const data = JSON.parse(err.responseText);\n              reject(new Error(data.error));\n            } catch (ex) {\n              reject(new Error(err.statusText));\n            }\n          } else if (err.statusText) {\n            reject(new Error(err.statusText));\n          } else {\n            reject(new Error(err));\n          }\n        },\n        false,\n      );\n    });\n  },\n});\n\nTrack.addInitHook('_createFileLoader');\n","const L = require('leaflet');\nconst { Track, track } = require('./Track');\nconst { ToolBar, toolBar } = require('./ToolBar');\nconst { TraceModeBar, traceModeBar } = require('./TraceModeBar');\nconst LayerContainer = require('./LayerContainer');\nconst { Node, node } = require('./Node');\nconst { Edge, edge } = require('./Edge');\nconst colors = require('./Colors');\nrequire('./Loader');\nconst latlngutils = require('./LatLngUtils');\n\n/** @module L.TrackDrawer */\nL.TrackDrawer = {\n  Track,\n  track,\n  ToolBar,\n  toolBar,\n  TraceModeBar,\n  traceModeBar,\n  LayerContainer,\n  Node,\n  node,\n  Edge,\n  edge,\n  colors,\n  latlngutils,\n};\n\nmodule.exports = L.TrackDrawer;\n"],"names":["colorMap","red","orange","green","blue","purple","darkred","darkblue","darkgreen","darkpurple","cadetblue","lightred","beige","lightgreen","lightblue","pink","white","lightgray","gray","black","colors","Object","freeze","nameOf","idx","length","rgbOf","this","nameToRgb","name","rgbToName","rgb","keys","find","key","L","Evented","extend","initialize","parent","_parent","f","featureGroup","addTo","addEventParent","_elements","get","i","splice","ret","arguments","forEach","x","removeFrom","_this","removeEventParent","args","Array","prototype","slice","call","cb","clean","clearLayers","getLayer","id","parentLayer","undefined","getLayerId","layer","hasLayer","getLayerIndex","findIndex","Edge","Polyline","_startMarkerId","_endMarkerId","_promoted","_demoted","_computation","options","metadata","latlngs","setOptions","JSON","parse","stringify","edge","require$$0","encodeLatLngs","array","size","push","lat","lng","decodeLatLngs","latLng","encodeLatLng","latlng","decodeLatLng","Track","LayerGroup","routingCallback","router","debug","undoable","undoDepth","_getPrevious","node","previousEdge","_getEdge","_routeIdPrevious","previousNode","_getNode","_getNext","nextEdge","_routeIdNext","nextNode","_getNodeId","_nodesContainers","_getEdgeId","_edgesContainers","_getNodeContainerIndex","_getNodeContainer","_getEdgeContainerIndex","_getEdgeContainer","LayerContainer","_firstNodeId","_lastNodeId","_currentColorIndex","_fireEvents","_computing","_states","_currentStateIndex","getState","previousMarker","marker","done","route","Routing","waypoint","getLatLng","err","result","coordinates","hasNodes","count","counter","container","group","getLayers","getNodes","nodes","markers","getNodesContainer","getSteps","steps","edges","getStepsContainer","getBounds","bounds","latLngBounds","getLatLngs","hasTrackStats","TrackStats","currentNode","l","_this2","e","cache","getAll","type","_stopoversToGeoJSON","stopovers","features","_this3","properties","index","geometry","z","_edgesToFlatGeoJSON","feature","_this4","e2","_edgesToGeoJSON","_c","_this5","toGeoJSON","exportStopovers","exportAsFlat","geojson","state","version","start","_this6","end","_fireStart","payload","fire","_fireDone","_pushState","_fireFailed","error","message","refreshEdges","callback","_this7","oldValue","promises","onMoveNode","Promise","all","_createNode","TrackDrawer","restoreState","nodeCallback","_this8","routes","segment","j","addNode","from","to","Error","m","promoteNodeToStopover","_undoing","undo","_this9","isUndoable","isRedoable","redo","_this10","addLayer","Marker","_createEdge","edgesContainer","color","Colors","colorName","dashArray","on","startNodeId","endNodeId","setTooltipContent","_this11","bindTooltip","_prepareNode","nodesContainer","_this12","setStyle","draggable","_onDragStartNode","target","_onDragNode","skipChecks","equals","resolve","lastNodeId","then","_this13","currentComputation","reject","setLatLng","setLatLngs","insertNode","startMarker","endMarker","edge1","edge2","currentComputation1","currentComputation2","promise1","route1","metadata1","promise2","route2","metadata2","_this14","_this15","removeNode","demoteNodeToWaypoint","nodeContainer","_this16","setType","newNodesContainer","newEdgesContainer","_this17","previousNodesContainer","previousEdgesContainer","_this18","track","Control","EasyBar","module","ToolBar","toolBar","mode","labelAddMarker","labelInsertMarker","labelCloseLoop","labelDeleteMarker","labelPromoteMarker","labelDemoteMarker","labelClean","labelUndo","labelRedo","_track","Util","_initializeButtons","setMode","weight","_bindMarkerEvents","_toolbar","_addBtn","_insertBtn","_deleteBtn","_promoteBtn","_demoteBtn","_map","getContainer","style","cursor","buttons","easyButton","states","stateName","icon","title","onClick","_closeLoop","_cleanBtn","_undoBtn","_redoBtn","disable","enable","_onMarkerClickHandler","_onMarkerMouseOverHandler","_onMarkerMouseOutHandler","onAdd","map","_onMapClickHandler","DomEvent","onRemove","off","TraceModeBar","traceModeBar","modes","_buttonsMap","ids","newMode","btn","Node","opacity","setIcon","AwesomeMarkers","markerColor","prefix","setOpacity","splitLatLngs","distance","isArray","concat","tmp","distanceTo","featureGroupToPolylines","filter","splitPolyline","polyline","a","featureGroupToLatLngs","include","_createFileLoader","_fileLoader","FileLayer","fileLoader","addToMap","fileSizeLimit","formats","fileFormat","createFileLoaderControl","insertWaypoints","_fileLoaderController","fileLayerLoad","loader","event","_dataLoadedHandler","latlngutils","hasToolbar","lastMarker","_n1","_n2","loadData","data","ext","loadFile","file","load","loadUrl","url","useProxy","filename","split","pop","proxiedUrl","encodeURI","corslite","resp","responseText","ex","statusText","addInitHook","require$$1","require$$2","require$$3","require$$4"],"mappings":"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"}